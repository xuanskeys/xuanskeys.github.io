<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java并发编程3(CAS) | XuanCode</title><meta name="author" content="xuanskeys"><meta name="copyright" content="xuanskeys"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java内存模型(JMM)概念百度百科：java内存模型_百度百科  Java内存模型（Java Memory Model, JMM）是Java语言规范的一部分，它定义了程序中各个线程如何通过内存进行通信的规则。这个模型确保了在多线程环境下，不同线程对共享变量的操作具有一定的可见性和有序性，从而避免了一些潜在的问题，如竞态条件和内存一致性错误。  JMM特性 可见性：指的是一个线程对共享变量所做的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程3(CAS)">
<meta property="og:url" content="http://xuanskeys.github.io/2025/04/20/JUC3/index.html">
<meta property="og:site_name" content="XuanCode">
<meta property="og:description" content="Java内存模型(JMM)概念百度百科：java内存模型_百度百科  Java内存模型（Java Memory Model, JMM）是Java语言规范的一部分，它定义了程序中各个线程如何通过内存进行通信的规则。这个模型确保了在多线程环境下，不同线程对共享变量的操作具有一定的可见性和有序性，从而避免了一些潜在的问题，如竞态条件和内存一致性错误。  JMM特性 可见性：指的是一个线程对共享变量所做的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xuanskeys.github.io/image/person.jpg">
<meta property="article:published_time" content="2025-04-20T01:59:28.000Z">
<meta property="article:modified_time" content="2025-04-20T02:00:43.376Z">
<meta property="article:author" content="xuanskeys">
<meta property="article:tag" content="1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xuanskeys.github.io/image/person.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java并发编程3(CAS)",
  "url": "http://xuanskeys.github.io/2025/04/20/JUC3/",
  "image": "http://xuanskeys.github.io/image/person.jpg",
  "datePublished": "2025-04-20T01:59:28.000Z",
  "dateModified": "2025-04-20T02:00:43.376Z",
  "author": [
    {
      "@type": "Person",
      "name": "xuanskeys",
      "url": "http://xuanskeys.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/%E5%AF%BF%E5%8F%B8.png"><link rel="canonical" href="http://xuanskeys.github.io/2025/04/20/JUC3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发编程3(CAS)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/styles/main.css"><script src="/styles/fish.js"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/person.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">XuanCode</span></a><a class="nav-page-title" href="/"><span class="site-name">Java并发编程3(CAS)</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java并发编程3(CAS)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-20T01:59:28.000Z" title="发表于 2025-04-20 09:59:28">2025-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-20T02:00:43.376Z" title="更新于 2025-04-20 10:00:43">2025-04-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1><span id="java内存模型jmm">Java内存模型(JMM)</span></h1><h2><span id="概念">概念</span></h2><p>百度百科：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3399303">java内存模型_百度百科</a></p>
<blockquote>
<p>Java内存模型（Java Memory Model, JMM）是Java语言规范的一部分，它定义了程序中各个线程如何通过内存进行通信的规则。这个模型确保了在多线程环境下，不同线程对共享变量的操作具有一定的可见性和有序性，从而避免了一些潜在的问题，如竞态条件和内存一致性错误。</p>
</blockquote>
<h2><span id="jmm特性">JMM特性</span></h2><ol>
<li><strong>可见性：</strong>指的是一个线程对共享变量所做的修改需要对其他线程变得可见。如果没有适当的同步机制，一个线程所做的更改可能不会立即或根本不会对其他线程显现出来。JMM通过使用volatile关键字、synchronized块或方法等机制来确保可见性。</li>
<li><strong>有序性：</strong>Java允许编译器和处理器对指令进行重排序以优化性能，只要这种重排序不改变程序在单线程环境下的行为。然而，在多线程环境中，这可能导致意外的行为。JMM通过规定happens-before原则和其他同步手段来防止有害的重排序，确保程序的执行顺序符合开发者的预期。</li>
<li><strong>原子性：</strong>指的是操作不可分割，要么全部执行，要么完全不执行。对于基本数据类型的读取和写入（除long和double外），Java保证它们是原子性的。但对于复合操作（如i++），则不是原子性的，可能会导致竞态条件。为了实现原子性，可以使用synchronized、显式锁或者java.util.concurrent.atomic包中的类。</li>
</ol>
<h1><span id="可见性">可见性</span></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2><span id="原因">原因</span></h2><ol>
<li><strong>处理器缓存（Cache）：</strong>为了减少访问主内存的延迟，每个处理器核心通常有自己的缓存（L1, L2, 甚至L3）。当一个线程在一个核心上修改了共享变量，这个更新首先发生在该核心的缓存中，并不会立刻写回到主内存。因此，运行在其他核心上的线程可能暂时看不到这个更新，因为它们可能会从自己的缓存中读取旧值。</li>
<li><strong>乱序执行（Out-of-order Execution）：</strong>为了优化性能，现代处理器可能会改变指令的实际执行顺序，只要这种重排序不影响单个线程内的程序结果。然而，在多线程环境中，这样的重排序可能导致一个线程所见的执行顺序不同于另一个线程，从而影响共享数据的一致性。</li>
<li><strong>编译器优化：</strong>编译器在编译程序时也会进行各种优化，包括指令重排、消除看似冗余的读写操作等。虽然这些优化在单线程环境下是安全的，但在多线程环境下可能会导致一个线程看不到另一个线程对共享变量所做的最新修改。</li>
<li><strong>存储一致性模型（Memory Consistency Models）：</strong>不同的硬件架构和编程语言实现有着不同的存储一致性模型。例如，x86架构提供相对较强的一致性保证，而ARM和PowerPC则允许更宽松的内存模型，这可能导致不同线程间观察到的程序行为有所不同。</li>
</ol>
<h2><span id="解决方式">解决方式</span></h2><ol>
<li><strong>使用同步机制</strong>：如互斥锁（mutex）、信号量（semaphore）等来保护共享资源，确保同一时间只有一个线程能够访问该资源。</li>
<li><strong>使用volatile关键字</strong>：在Java等语言中，声明一个变量为volatile可以保证对该变量的读写操作不会被编译器或处理器重排序，同时每次读取都会从主内存获取最新值，而不是使用本地缓存中的值。</li>
<li><strong>使用原子变量</strong>：原子变量提供了不依赖于锁机制的线程安全操作，适用于某些特定场景下的高效并发控制。</li>
<li><strong>使用高级同步结构</strong>：例如读写锁、条件变量、栅栏(barrier)等，可以根据具体情况提供更细粒度或更适合场景的同步方案。</li>
<li><strong>使用内存屏障（Memory Barrier）&#x2F; 内存栅栏（Memory Fence）</strong>：这是一种硬件级别的机制，可以防止编译器和CPU对指令进行跨屏障的重排序，确保某些操作的顺序性。</li>
</ol>
<h1><span id="有序性">有序性</span></h1><h2><span id="指令重排序引起的问题"><strong>指令重排序引起的问题：</strong></span></h2><p>​    为了提高执行效率，编译器和处理器可能对指令顺序进行调整，只要这种重排序不影响单个线程内的程序结果。但在多线程环境中，如果一个线程依赖另一个线程的操作结果，这种重排序可能导致未预期的行为。</p>
<h2><span id="解决方案">解决方案</span></h2><ol>
<li><strong>使用synchronized关键字</strong>：synchronized块或方法不仅能保证原子性，还能保证有序性和可见性。进入synchronized块时会插入内存屏障，确保所有之前的操作都已完成且对其他线程可见；退出时也会插入内存屏障，确保所有后续操作都不会被提前执行。</li>
<li><strong>使用volatile关键字</strong>：声明一个变量为volatile可以防止对其读写操作被重排序，并确保每次读取都会从主内存获取最新值，而不是从本地缓存中。这对于状态标志等简单的同步需求非常有用。</li>
<li><strong>使用java.util.concurrent包下的高级并发工具</strong>：如ReentrantLock, CountDownLatch, CyclicBarrier, Semaphore等，这些工具提供了比synchronized更丰富的功能，并且在很多情况下拥有更好的性能。</li>
<li><strong>使用原子变量类</strong>：如AtomicInteger, AtomicLong, AtomicReference等，它们提供了一种无锁的方式来处理共享数据，基于现代CPU的CAS（Compare-And-Swap）特性实现，既保证了原子性也保证了有序性和可见性。</li>
<li><strong>使用final关键字</strong>：对于对象引用和不可变对象，使用final字段可以在对象构造期间保护其初始化的安全性，确保对象一旦构造完成，其状态就不会再受到重排序的影响。</li>
</ol>
<h1><span id="volatile关键字"><strong>volatile关键字</strong></span></h1><p> volatile关键字在Java中用于确保变量的可见性和禁止某些类型的指令重排序，它主要用于解决多线程环境下的可见性问题。</p>
<h2><span id="可见性">可见性</span></h2><ul>
<li>当一个线程对volatile变量进行写操作时，这个<strong>写操作会立即被刷新到主内存</strong>中，而不是停留在处理器缓存中。</li>
<li>当另一个线程随后读取同一个volatile变量时，<strong>它会从主内存中获取最新的值</strong>，而不是使用处理器缓存中的副本。</li>
</ul>
<p>这意味着，通过使用volatile关键字声明的变量可以保证一个线程对变量所做的修改能够立即对其他线程可见，解决了由于缓存导致的可见性问题。</p>
<h2><span id="禁止指令重排序">禁止指令重排序</span></h2><ul>
<li>volatile还提供了一种“happens-before”的关系，确保了对该变量的操作不会被编译器或处理器重排序到不恰当的位置。</li>
</ul>
<p>更具体地说，<strong>对volatile变量的写入操作必须在任何后续对该变量的读取操作之前完成</strong>（根据程序顺序）。这有助于避免由于指令重排序导致的竞态条件或其他并发问题。</p>
<h1><span id="happens-before"><strong>happens-before</strong></span></h1><h2><span id="概念"><strong>概念</strong></span></h2><p> “Happens-before”是Java内存模型（JMM）中的一个概念，用于描述程序中操作之间的部分有序关系，确保多线程环境下的可见性和有序性。简单来说，“happens-before”规则定义了一个操作何时以及如何对另一个操作可见。如果操作A “happens-before” 操作B，则A所做的所有影响（包括变量的写入）都必须在B执行时可见。</p>
<h2><span id="规则">规则</span></h2><ol>
<li><strong>程序顺序规则：</strong>每个线程内部的操作按照程序代码的顺序执行，“happens-before”于该线程后续的操作。尽管编译器和处理器可以对指令进行重排序优化，但这些重排序不能改变单个线程内的程序顺序。</li>
<li><strong>监视器锁规则：</strong>对同一个锁的解锁操作“happens-before”随后对该锁的加锁操作。这意味着在一个线程释放锁之后对共享变量所做的任何修改，在其他线程获取到这个锁后都是可见的。</li>
<li><strong>volatile字段规则：</strong>对volatile变量的写入操作“happens-before”所有后续对该变量的读取操作。这保证了当一个线程写入一个volatile变量后，所有其它线程都能看到这个写入动作的效果。</li>
<li><strong>线程启动规则：</strong>Thread.start()方法调用“happens-before”由该线程执行的所有操作。这意味着主线程在调用新线程的start()方法之前所做的任何初始化工作对于新线程来说都是可见的。</li>
<li><strong>线程结束规则：</strong>由某个线程执行的所有操作“happens-before”其他线程通过Thread.join()成功返回。即，一个线程等待另一个线程结束，并且能够看到那个线程所有的操作结果。</li>
<li><strong>传递性：</strong>如果操作A “happens-before” 操作B，而操作B又 “happens-before” 操作C，那么操作A “happens-before” 操作C。</li>
</ol>
<h1><span id="并发设计模式">并发设计模式</span></h1><h2><span id="概念">概念</span></h2><p>​    并发设计模式是专门用来解决多线程编程和并发计算中遇到的问题的设计模式。它们帮助开发者更好地管理资源共享、任务分配以及线程间通信，从而提高程序的性能和可靠性 </p>
<h2><span id="分类">分类</span></h2><h3><span id="生产者-消费者模式producer-consumer-pattern"><strong>生产者-消费者模式（Producer-Consumer Pattern）：</strong></span></h3><ul>
<li>这是一种经典的并发模式，用于解耦数据生产者和消费者。它通过一个共享队列来实现，生产者将数据放入队列，而消费者从队列中取出数据进行处理。</li>
</ul>
<h3><span id="读者-写者问题readers-writers-problem"><strong>读者-写者问题（Readers-Writers Problem）：</strong></span></h3><ul>
<li>解决了当存在多个读取者和写入者同时访问共享资源时的问题。目标是在最大化读操作并发性的同时保证写操作的数据一致性。</li>
</ul>
<h3><span id="单例模式singleton-with-double-checked-locking"><strong>单例模式（Singleton with Double-Checked Locking）：</strong></span></h3><ul>
<li>虽然单例模式本身不是专门为并发环境设计的，但在多线程环境下使用双重检查锁定机制可以确保只有一个实例被创建，同时减少同步带来的开销。</li>
</ul>
<h3><span id="锁与条件变量locks-and-condition-variables"><strong>锁与条件变量（Locks and Condition Variables）：</strong></span></h3><ul>
<li>提供了一种机制让线程之间能够相互等待直到某个条件成立。这通常涉及到互斥锁（mutex）和条件变量的使用。</li>
</ul>
<h3><span id="信号量semaphore"><strong>信号量（Semaphore）：</strong></span></h3><ul>
<li>用于控制对有限资源的访问，如限制数据库连接池中的最大连接数等。二元信号量（binary semaphore）特别类似于互斥锁。</li>
</ul>
<h3><span id="屏障barrier"><strong>屏障（Barrier）：</strong></span></h3><ul>
<li>允许一组线程全部到达某一点后继续执行。这对于需要所有线程完成当前阶段才能开始下一阶段的任务非常有用。</li>
</ul>
<h3><span id="future模式"><strong>Future模式：</strong></span></h3><ul>
<li>允许异步执行任务，并在将来某个时刻获取结果。Java中的Future接口和CompletableFuture类就是这种模式的实现。</li>
</ul>
<h3><span id="工作窃取work-stealing"><strong>工作窃取（Work Stealing）：</strong></span></h3><ul>
<li>在任务并行库（TPL）或类似框架中，工作窃取算法使得空闲线程可以从忙碌线程的工作队列末尾“偷取”任务来执行，以平衡负载。</li>
</ul>
<h3><span id="balking模式"><strong>Balking模式：</strong></span></h3><ul>
<li>当一个操作正在进行中时，阻止其他线程再次尝试执行相同的操作。例如，在自动保存场景下，如果用户已经手动保存，则自动保存过程会被取消。</li>
</ul>
<h3><span id="两阶段终止模式two-phase-termination-pattern"><strong>两阶段终止模式（Two-Phase Termination Pattern）：</strong></span></h3><ul>
<li>为了解决如何优雅地停止线程的问题，包括通知线程准备停止，并给线程机会清理资源。</li>
</ul>
<h2><span id></span></h2><h1><span id="无锁编程">无锁编程</span></h1><h2><span id="概念">概念</span></h2><p>无锁编程（Lock-Free Programming）是一种并发编程技术，旨在避免使用传统的锁机制来保护共享资源，从而减少死锁、优先级反转和性能瓶颈等问题。无锁算法通常依赖于原子操作（如比较并交换 Compare-And-Swap, CAS）来实现同步，确保即使在高并发条件下也能保证数据的一致性和正确性。 </p>
<h2><span id="主要技术">主要技术</span></h2><h3><span id="1-原子操作">1. 原子操作</span></h3><p>原子操作是无锁编程的基础，它保证了一系列操作要么全部执行完成，要么完全不执行，不会出现部分执行的情况。常见的原子操作包括：</p>
<ul>
<li><strong>Compare-And-Swap (CAS)：</strong>检查一个内存位置的值是否等于预期值，如果是，则用新值替换旧值。这是实现无锁算法最常用的原子操作。</li>
<li><strong>Fetch-And-Add：</strong>对指定内存位置的值进行原子加法操作，并返回该位置的原值。</li>
<li><strong>Load-Linked&#x2F;Store-Conditional (LL&#x2F;SC)：</strong>一种替代CAS的方法，首先通过Load-Linked读取一个值，然后尝试用Store-Conditional写入一个新值，只有在这两个操作之间没有其他线程修改过该位置时，写入才会成功。</li>
</ul>
<h3><span id="2-内存屏障x2f栅栏memory-barriersx2ffences">2. 内存屏障&#x2F;栅栏（Memory Barriers&#x2F;Fences）</span></h3><ul>
<li>内存屏障是一种同步指令，用于控制指令重排序和确保内存操作的顺序性。它们帮助程序员强制某些内存操作按照特定顺序执行，这对于维护多线程环境下的正确性至关重要。内存屏障分为几种类型，如加载屏障、存储屏障、全屏障等。</li>
</ul>
<h3><span id="3-aba问题解决方案">3. ABA问题解决方案</span></h3><p>ABA问题是无锁编程中的一个经典挑战，指的是某个变量先从A变为B再变回A，导致依赖于值比较的操作（如CAS）产生错误的行为。解决ABA问题的技术包括：</p>
<ul>
<li>版本号计数：为每个需要保护的数据项附加一个版本号或时间戳。每次更新数据项时也更新其版本号，这样即使值回到了原来的A，版本号也会不同，从而可以被检测到。</li>
<li>指针标记：在指针上添加额外的信息（例如低位作为标记），使得即使指针指向的对象地址相同，但标记位不同也能区分不同的状态。</li>
</ul>
<h3><span id="4-设计高效的无锁数据结构">4. 设计高效的无锁数据结构</span></h3><p>设计高效的无锁数据结构是无锁编程的核心任务之一。常见的无锁数据结构包括但不限于：</p>
<ul>
<li>无锁栈（Lock-Free Stack）：通过使用CAS操作来安全地推入和弹出元素。</li>
<li>无锁队列（Lock-Free Queue）：如Michael-Scott非阻塞队列算法，它允许多个线程同时进行入队和出队操作而不互相干扰。</li>
<li>无锁哈希表（Lock-Free Hash Table）：通过细粒度锁定或者基于CAS的操作来管理哈希冲突和扩容。</li>
</ul>
<h3><span id="5-非阻塞同步策略">5. 非阻塞同步策略</span></h3><p>除了上述具体的技术外，还有一些高层次的设计策略可以帮助构建无锁系统：</p>
<ul>
<li>乐观并发控制（Optimistic Concurrency Control, OCC）：假设冲突很少发生，在提交更改之前检查是否有冲突；如果发现冲突，则回滚并重试。</li>
<li>惰性同步（Lazy Synchronization）：推迟某些同步操作直到绝对必要时才执行，以减少同步开销。</li>
</ul>
<h2><span id="为什么无锁效率高"><strong>为什么无锁效率高</strong></span></h2><p><strong>1. 减少上下文切换</strong></p>
<p>在基于锁的并发控制中，如果一个线程持有锁而其他线程尝试获取相同的锁时，那些未能获得锁的线程会被阻塞，这意味着它们必须等待直到锁可用。这种等待会导致操作系统进行线程上下文切换，这是一项昂贵的操作，因为它涉及保存当前线程的状态并加载另一个线程的状态。</p>
<p>相比之下，无锁算法允许所有线程继续运行，即使某个操作失败了（例如 compareAndSet 返回 false），它也只是简单地重试，而不是被阻塞或暂停执行。这样可以显著减少不必要的上下文切换，从而提高系统整体性能。</p>
<p><strong>2. 避免死锁和优先级反转</strong></p>
<p>使用传统的锁机制时，可能会遇到复杂的问题如死锁（Deadlock）和优先级反转（Priority Inversion）。这些问题可能导致部分或全部线程永久挂起，严重影响系统的响应性和稳定性。无锁算法通过消除锁的使用自然避免了这些问题的发生。</p>
<p><strong>3. 更好的可伸缩性</strong></p>
<p>随着处理器核心数量的增加，能够有效利用多核架构变得至关重要。无锁算法由于不依赖于全局锁，因此可以在多个核心上同时执行不同的任务而不互相干扰，从而更好地利用硬件资源。相反，基于锁的设计可能会成为瓶颈，尤其是在高争用的情况下，因为所有的线程都试图访问同一个锁。</p>
<p><strong>4. 原子操作的高效性</strong></p>
<p>现代CPU提供了对原子操作的强大支持，比如 Compare-And-Swap (CAS) 操作。这些原子指令能够在硬件层面保证某些类型的同步操作是原子性的，无需额外的软件层同步开销。虽然单个 CAS 操作可能并不总是成功，但它的失败处理非常轻量级——通常是立即重试或者根据策略短暂等待后再重试，而不是像锁那样导致线程进入等待状态。</p>
<p><strong>5. 降低锁争用带来的开销</strong></p>
<p>在高度竞争的环境中，锁争用会导致严重的性能下降。每个试图获取已被占用的锁的尝试都会失败，并且线程不得不等待。而在无锁算法中，尽管也可能存在“竞争”——即多个线程同时尝试修改同一数据结构的情况，但是这种竞争是以非阻塞的方式处理的，允许失败的操作快速重试，而不是陷入长时间的等待。</p>
<h2><span id="cas是什么">CAS是什么</span></h2><p>CAS是一种硬件提供的原子操作，它接受三个参数：内存位置（V）、预期原值（A）和新值（B）。这个操作的功能是仅当内存位置V的当前值等于预期原值A时，才将V的值更新为新值B，并返回操作是否成功的布尔值。如果在此期间另一个线程改变了V的值，使得其不再等于A，则该操作失败，通常会重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> V.compareAndSet(expectedValue, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2><span id="账户余额管理功能案例分析">账户余额管理功能案例分析</span></h2><h3><span id="账户接口">账户接口</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程列表，用于存储即将创建的1000个线程</span></span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录操作开始的时间，用于计算操作耗时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环创建1000个线程，每个线程执行的操作是：从账户中取款10元</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程，让它们开始执行取款操作</span></span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程完成取款操作，确保主线程在所有取款线程完成后才继续执行</span></span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录操作结束的时间，用于计算操作耗时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印账户余额和操作耗时</span></span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3><span id="线程不安全的情况">线程不安全的情况</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountUnsafeImpl</span> <span class="keyword">implements</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafeImpl</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3><span id="通过锁实现线程安全">通过锁实现线程安全</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountSafeImplSychronized</span> <span class="keyword">implements</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountSafeImplSychronized</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3><span id="无锁实现线程安全">无锁实现线程安全</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountSafeImpl</span> <span class="keyword">implements</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountSafeImpl</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 无限循环，尝试更新余额，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前余额</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="comment">// 计算消费后的余额</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="comment">// 尝试更新余额，如果成功则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3><span id="测试">测试：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建账户</span></span><br><span class="line">log.debug(<span class="string">&quot;线程不安全的情况：&quot;</span>);</span><br><span class="line">Account.demo(<span class="keyword">new</span> <span class="title class_">AccountUnsafeImpl</span>(<span class="number">10000</span>));</span><br><span class="line">log.debug(<span class="string">&quot;线程安全(锁)的情况：&quot;</span>);</span><br><span class="line">Account.demo(<span class="keyword">new</span> <span class="title class_">AccountSafeImplSychronized</span>(<span class="number">10000</span>));</span><br><span class="line">log.debug(<span class="string">&quot;线程安全(无锁)的情况：&quot;</span>);</span><br><span class="line">Account.demo(<span class="keyword">new</span> <span class="title class_">AccountSafeImpl</span>(<span class="number">10000</span>));</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="/./../images/368c13318e6b4b8b98960b5f976765a7.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<h3><span id="分析无锁实现线程安全">分析无锁实现线程安全：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    <span class="comment">// 无限循环，尝试更新余额，直到成功</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前余额</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">        <span class="comment">// 计算消费后的余额</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">        <span class="comment">// 尝试更新余额，如果成功则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<blockquote>
<ul>
<li>使用 while(true) 循环不断尝试更新余额，直到成功为止。</li>
<li>compareAndSet(prev, next) 方法用于比较当前余额是否为预期值 (prev)，如果是，则将余额设置为新值 (next)。如果不是，则说明在此期间有其他线程修改了余额，因此当前线程会再次尝试。</li>
<li>这种方式确保了即使在并发环境中，余额的更新也能正确完成，不会出现数据竞争或其他一致性问题。</li>
</ul>
</blockquote>
<h4><span id="源码分析">源码分析：</span></h4><p>看一下AtomicInteger底层实现：</p>
<p>可以发现通过AtomicInteger包裹整型，底层使用volatile关键字，保证了可见性和禁止指令重排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> compareAndSet方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<blockquote>
<p>该代码实现了原子级别的比较并设置操作：</p>
<ul>
<li>如果当前值等于期望值，则将值更新为新值，并返回true。</li>
<li>如果当前值不等于期望值，则不进行更新，返回false。</li>
<li>使用Unsafe类的compareAndSwapInt方法实现底层的CAS（Compare-And-Swap）操作。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<hr>
<p><strong>如有错误，欢迎指正！！！</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://xuanskeys.github.io">xuanskeys</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://xuanskeys.github.io/2025/04/20/JUC3/">http://xuanskeys.github.io/2025/04/20/JUC3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://xuanskeys.github.io" target="_blank">XuanCode</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/1/">1</a></div><div class="post-share"><div class="social-share" data-image="/image/person.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/20/JUC2/" title="Java并发编程2(锁-Sychronized)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java并发编程2(锁-Sychronized)</div></div><div class="info-2"><div class="info-item-1">认识Java对象头  32位虚拟机对象头：   64位虚拟机对象头：     1.Mark Word（标记字）:  Mark Word是对象头的一部分，用于存储对象自身的哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID（或偏向时间戳）、偏向模式以及锁的状态等信息。 标记字的大小和具体内容可能因JVM实现的不同而有所变化。例如，在64位JVM上，默认情况下Mark Word占用64位（8字节），而在32位JVM上则是32位（4字节）。  2.Class Pointer（类指针）:  这是指向该对象对应类（Class）的指针，通过这个指针可以访问到对象所属类的元数据（如方法表、字段描述等）。类指针的大小依赖于JVM的具体实现及其是否开启了压缩指针（Compressed Oop）选项。 在某些情况下，比如当使用了-XX:+UseCompressedClassPointers选项时，类指针会被压缩以节省内存。  3.Array...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC4/" title="Java并发编程4（JUC篇）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java并发编程4（JUC篇）</div></div><div class="info-2"><div class="info-item-1">本篇文章重点介绍JUC（java.util.concurrent）  JUC是”java.util.concurrent”包的简称，它是Java提供的一个并发工具包，旨在简化多线程编程，提供了丰富的类和接口来帮助开发者更高效、更安全地编写并发程序。JUC包增强了Java对并发的支持，解决了传统多线程编程中的一些难题，如死锁、竞争条件和资源管理等。    原子变量  基本类型原子变量 AtomicInteger  提供对整型值的原子操作，如加法、减法等。 方法示例：incrementAndGet(), decrementAndGet(), addAndGet(int delta), compareAndSet(int expect, int update)。  AtomicLong  类似于AtomicInteger，但是针对长整型（long）值。 方法与AtomicInteger相似，适用于需要处理较大数值的情况。  AtomicBoolean  支持布尔类型的原子操作。 方法示例：get(), set(boolean newValue),...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/21/CentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="CentOS 7环境搭建"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-21</div><div class="info-item-2">CentOS 7环境搭建</div></div><div class="info-2"><div class="info-item-1">CentOS 7环境搭建我的基础环境：  CentOS版本：CentOS Linux release 7.7.1908 (Core) Vmware版本：VMware® Workstation 17 Pro 17.5.0 build-22583795   注意：  所有有关防火墙的操作都可以不开端口，但是我为了测试方便我就开了端口号，便于后续本地测试，这个自行选择。 我所有的安装指令都是在root用户权限下执行的。 参考：软件安装 | CodeSheep 如有错误，欢迎指正！   1.验证网络连通性12ping 8.8.8.8ping www.baidu.com   连不通的，去修改一下&#x2F;etc&#x2F;resolv.conf下的dns配置 12345# /etc/resolv.confnameserver 223.5.5.5      # 阿里云主DNSnameserver 223.6.6.6      # 阿里云备DNSnameserver 114.114.114.114 # 114公共DNS（备用）nameserver 8.8.8.8        #...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC1/" title="JUC并发编程1(初识进程和线程)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">JUC并发编程1(初识进程和线程)</div></div><div class="info-2"><div class="info-item-1"> 初识进程和线程初识进程：定义：  进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。（百度百科） 进程由程序、数据和进程控制块三部分组成。   什么是进程？ 狭义定义：进程是正在运行的程序的实例。 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。   eg：进程可以看做是程序的实例，你可以打开多个程序，每一个程序就是一个进程（比如你重复打开QQ登录不同的用户，每一个用户登录的那个程序就是一个进程）。   如果你关闭一个窗口，那么这个进程也就结束了  概念：1.进程是一个实体。 ...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC2/" title="Java并发编程2(锁-Sychronized)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java并发编程2(锁-Sychronized)</div></div><div class="info-2"><div class="info-item-1">认识Java对象头  32位虚拟机对象头：   64位虚拟机对象头：     1.Mark Word（标记字）:  Mark Word是对象头的一部分，用于存储对象自身的哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID（或偏向时间戳）、偏向模式以及锁的状态等信息。 标记字的大小和具体内容可能因JVM实现的不同而有所变化。例如，在64位JVM上，默认情况下Mark Word占用64位（8字节），而在32位JVM上则是32位（4字节）。  2.Class Pointer（类指针）:  这是指向该对象对应类（Class）的指针，通过这个指针可以访问到对象所属类的元数据（如方法表、字段描述等）。类指针的大小依赖于JVM的具体实现及其是否开启了压缩指针（Compressed Oop）选项。 在某些情况下，比如当使用了-XX:+UseCompressedClassPointers选项时，类指针会被压缩以节省内存。  3.Array...</div></div></div></a><a class="pagination-related" href="/2025/04/27/JavaScript/" title="JavaScript"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">JavaScript</div></div><div class="info-2"><div class="info-item-1">JavaScriptJavaScript是什么? JavaScript 是脚本语言  JavaScript 是一种轻量级的编程语言。  JavaScript 是可插入 HTML 页面的编程代码。  JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。   怎么定义？HTML 中的 Javascript 脚本代码必须位于  与  标签之间。 Javascript 脚本代码可被放置在 HTML 页面的  和  部分中。 JS显示数据 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。  JS数据格式数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e)。 字符串（String）字面量 可以使用单引号或双引号: 表达式字面量 用于计算：5 + 6 5 * 6 数组（Array）字面量 [40, 100, 1, 5, 25, 10] 对象（Object）字面量...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC4/" title="Java并发编程4（JUC篇）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java并发编程4（JUC篇）</div></div><div class="info-2"><div class="info-item-1">本篇文章重点介绍JUC（java.util.concurrent）  JUC是”java.util.concurrent”包的简称，它是Java提供的一个并发工具包，旨在简化多线程编程，提供了丰富的类和接口来帮助开发者更高效、更安全地编写并发程序。JUC包增强了Java对并发的支持，解决了传统多线程编程中的一些难题，如死锁、竞争条件和资源管理等。    原子变量  基本类型原子变量 AtomicInteger  提供对整型值的原子操作，如加法、减法等。 方法示例：incrementAndGet(), decrementAndGet(), addAndGet(int delta), compareAndSet(int expect, int update)。  AtomicLong  类似于AtomicInteger，但是针对长整型（long）值。 方法与AtomicInteger相似，适用于需要处理较大数值的情况。  AtomicBoolean  支持布尔类型的原子操作。 方法示例：get(), set(boolean newValue),...</div></div></div></a><a class="pagination-related" href="/2025/04/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java虚拟机</div></div><div class="info-2"><div class="info-item-1">JVM的概念百度百科：java虚拟机 什么是虚拟机？虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。 为什么要有JVM？  Java设计的初衷是使要建的能在任何平台上运行的程序不需要再在每个单独的平台上由程序员进行重写或重编译。 Java虚拟机使这个愿望变为可能，因为它能知道每条指令的长度和平台的其他特性。 JVM的设计目标是提供一个基于抽象规格描述的计算机模型，为解释程序开发人员提供的任何系统上运行。   什么是java虚拟机?JVM全称Java Virtual...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/person.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xuanskeys</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xuanskeys"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到XuanCode。更多详细信息请前往CSDN：https://blog.csdn.net/m0_73569492?type=blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java内存模型(JMM)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">JMM特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">解决方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">指令重排序引起的问题：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.2.</span> <span class="toc-text">禁止指令重排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">happens-before</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.2.</span> <span class="toc-text">规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">并发设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.2.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.1.</span> <span class="toc-text">生产者-消费者模式（Producer-Consumer Pattern）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.2.</span> <span class="toc-text">读者-写者问题（Readers-Writers Problem）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.3.</span> <span class="toc-text">单例模式（Singleton with Double-Checked Locking）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.4.</span> <span class="toc-text">锁与条件变量（Locks and Condition Variables）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.5.</span> <span class="toc-text">信号量（Semaphore）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.6.</span> <span class="toc-text">屏障（Barrier）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.7.</span> <span class="toc-text">Future模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.8.</span> <span class="toc-text">工作窃取（Work Stealing）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.9.</span> <span class="toc-text">Balking模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.10.</span> <span class="toc-text">两阶段终止模式（Two-Phase Termination Pattern）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">无锁编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.2.</span> <span class="toc-text">主要技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.2.1.</span> <span class="toc-text">1. 原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.2.2.</span> <span class="toc-text">2. 内存屏障&#x2F;栅栏（Memory Barriers&#x2F;Fences）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.2.3.</span> <span class="toc-text">3. ABA问题解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.2.4.</span> <span class="toc-text">4. 设计高效的无锁数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.2.5.</span> <span class="toc-text">5. 非阻塞同步策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.3.</span> <span class="toc-text">为什么无锁效率高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.4.</span> <span class="toc-text">CAS是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.5.</span> <span class="toc-text">账户余额管理功能案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.5.1.</span> <span class="toc-text">账户接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.5.2.</span> <span class="toc-text">线程不安全的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.5.3.</span> <span class="toc-text">通过锁实现线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.5.4.</span> <span class="toc-text">无锁实现线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.5.5.</span> <span class="toc-text">测试：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.5.6.</span> <span class="toc-text">分析无锁实现线程安全：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">7.5.6.1.</span> <span class="toc-text">源码分析：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/13/Netty/" title="Netty">Netty</a><time datetime="2025-05-13T15:15:00.000Z" title="发表于 2025-05-13 23:15:00">2025-05-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/29/Vue3/" title="无标题">无标题</a><time datetime="2025-04-29T09:51:08.718Z" title="发表于 2025-04-29 17:51:08">2025-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/JavaScript/" title="JavaScript">JavaScript</a><time datetime="2025-04-27T00:24:00.000Z" title="发表于 2025-04-27 08:24:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/26/Spring%20MVC/" title="Spring MVC">Spring MVC</a><time datetime="2025-04-26T00:24:00.000Z" title="发表于 2025-04-26 08:24:00">2025-04-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/24/WebSocket/" title="无标题">无标题</a><time datetime="2025-04-24T11:57:33.742Z" title="发表于 2025-04-24 19:57:33">2025-04-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By xuanskeys</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: 'xuanskeys.github.io',
      owner: 'xuanskeys',
      admin: ['xuanskeys'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '49f2448aad5bf66e7afd8b2606a87d9d'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>