<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java虚拟机 | XuanCode</title><meta name="author" content="xuanskeys"><meta name="copyright" content="xuanskeys"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM的概念百度百科：java虚拟机 什么是虚拟机？虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。 为什么要有JVM？  Java设计的初衷是使要建的能在任何平台上运行的程序不需要再在每个单独的平台上由程序员进行重写或重编译。 Java虚拟机使这个愿望变为可能，因为它能知道每条指令的长度和平台的其他特性。 JVM的设计目标是提供一个基于抽象规格描述的计算机模型，为">
<meta property="og:type" content="article">
<meta property="og:title" content="Java虚拟机">
<meta property="og:url" content="http://xuanskeys.github.io/2025/04/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html">
<meta property="og:site_name" content="XuanCode">
<meta property="og:description" content="JVM的概念百度百科：java虚拟机 什么是虚拟机？虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。 为什么要有JVM？  Java设计的初衷是使要建的能在任何平台上运行的程序不需要再在每个单独的平台上由程序员进行重写或重编译。 Java虚拟机使这个愿望变为可能，因为它能知道每条指令的长度和平台的其他特性。 JVM的设计目标是提供一个基于抽象规格描述的计算机模型，为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xuanskeys.github.io/image/person.jpg">
<meta property="article:published_time" content="2025-04-20T02:07:29.000Z">
<meta property="article:modified_time" content="2025-04-20T02:08:32.406Z">
<meta property="article:author" content="xuanskeys">
<meta property="article:tag" content="1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xuanskeys.github.io/image/person.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java虚拟机",
  "url": "http://xuanskeys.github.io/2025/04/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/",
  "image": "http://xuanskeys.github.io/image/person.jpg",
  "datePublished": "2025-04-20T02:07:29.000Z",
  "dateModified": "2025-04-20T02:08:32.406Z",
  "author": [
    {
      "@type": "Person",
      "name": "xuanskeys",
      "url": "http://xuanskeys.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/%E5%AF%BF%E5%8F%B8.png"><link rel="canonical" href="http://xuanskeys.github.io/2025/04/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java虚拟机',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/styles/main.css"><script src="/styles/fish.js"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/person.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">XuanCode</span></a><a class="nav-page-title" href="/"><span class="site-name">Java虚拟机</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java虚拟机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-20T02:07:29.000Z" title="发表于 2025-04-20 10:07:29">2025-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-20T02:08:32.406Z" title="更新于 2025-04-20 10:08:32">2025-04-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1><span id="jvm的概念">JVM的概念</span></h1><p>百度百科：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/java%E8%99%9A%E6%8B%9F%E6%9C%BA/6810577">java虚拟机</a></p>
<h3><span id="什么是虚拟机">什么是虚拟机？</span></h3><p>虚拟机是一种抽象化的计算机，通过在实际的计算机上<strong>仿真模拟各种计算机</strong>功能来实现的。</p>
<h3><span id="为什么要有jvm">为什么要有JVM？</span></h3><blockquote>
<ul>
<li>Java设计的初衷是使要建的<strong>能在任何平台上运行的程序</strong>不需要再在每个单独的平台上由程序员进行重写或重编译。</li>
<li>Java虚拟机使这个愿望变为可能，因为它<strong>能知道每条指令的长度和平台的其他特性</strong>。</li>
<li>JVM的设计目标是提供一个基于抽象规格描述的计算机模型，为解释程序开发人员提供的任何系统上运行。</li>
</ul>
</blockquote>
<h3><span id="什么是java虚拟机">什么是java虚拟机?</span></h3><p>JVM全称Java Virtual Machine</p>
<blockquote>
<ul>
<li><strong>Java虚拟机有自己完善的硬体架构</strong>，如处理器、堆栈、寄存器等，还具有相应的指令系统。</li>
<li>运行所有Java程序的<strong>抽象计算机</strong>，是Java语言的运行环境</li>
<li>Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。</li>
<li>一旦一个Java虚拟机在给定的平台上运行，任何Java程序（编译之后的程序，称作字节码）都能在这个平台上运行。<strong>“一次编写，到处运行”</strong></li>
<li>Java虚拟机（JVM）可以以一次一条指令的方式来解释字节码（把它映射到实际的处理器指令），或者字节码也可以由实际处理器中称作just-in-time的编译器进行进一步的编译</li>
</ul>
</blockquote>
<p> 白话文理解一下：</p>
<blockquote>
<p>​      想象一下，您写了一篇非常特别的文章（Java程序），但是这篇文章需要用一种特殊的“万能语言”（字节码）来书写，这样它才能在任何地方被理解。然而，要读懂这种“万能语言”，人们需要一个特殊的翻译机（JVM）。</p>
<p>​    这个翻译机不仅能够读懂您的文章，还能把它转换成当地语言（机器指令），以便任何人（任何操作系统和硬件）都能理解。</p>
<p>​    现在，如果每次有人想读您的文章，都需要自己造一台这样的翻译机，那将是非常麻烦且耗时的。这就是为什么我们需要JVM——一个通用的翻译机，它可以安装在各种不同的设备上。一旦设备上有了这个翻译机，无论何时何地，只要把您的文章放进去，它就能立刻翻译并让大家读懂。</p>
<p>​    所以，别人想要运行您写的Java程序时，并不需要重新制造一台新的翻译机，只需要确保他们的设备上已经安装了合适的翻译机（即对应版本的JVM）。这样一来，他们就可以轻松运行您的程序，而无需担心底层的细节问题。</p>
<p>​    总结来说，JVM就像是一个专为Java程序设计的“虚拟计算机”。它允许您编写的程序在任何安装了适当版本JVM的设备上运行，极大地简化了跨平台应用的开发和部署过程。通过这种方式，Java实现了“编写一次，到处运行”的理念。</p>
</blockquote>
<h1><span id="jvm的组成">JVM的组成</span></h1><p><img src="/./../images/5614b03a0be04d9183a4087a87bf8a6b.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<h3><span id="类加载器classloader">类加载器（ClassLoader）：</span></h3><p>负责加载.class文件中的字节码到内存中，并将这些字节码转换为可以由JVM执行的形式。</p>
<p>类加载器有三个主要类型：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong></li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong></li>
<li><strong>应用类加载器（Application ClassLoader）</strong></li>
</ul>
<h3><span id="运行时数据区runtime-data-area">运行时数据区（Runtime Data Area）：</span></h3><p>这部分包括了多个关键的数据区域，用于存储程序运行期间需要的数据：</p>
<ul>
<li><strong>方法区（Method Area）</strong>：存储已被虚拟机加载的类信息、常量、静态变量等。</li>
<li><strong>堆（Heap）</strong>：存放对象实例以及数组，是垃圾回收的主要区域。</li>
<li><strong>虚拟机栈（VM Stack）</strong>：每个线程在创建时都会创建一个私有的栈，用来存储栈帧，栈帧中包含了局部变量表、操作数栈、动态链接等信息。</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：与虚拟机栈类似，但主要是为执行本地方法服务的。</li>
<li><strong>程序计数器（Program Counter Register</strong>）：每个线程都有自己的程序计数器，指向当前线程正在执行的字节码指令地址。</li>
</ul>
<h3><span id="执行引擎execution-engine">执行引擎（Execution Engine）：</span></h3><p>执行引擎负责解释或编译字节码并执行它。主要包括以下几部分：</p>
<ul>
<li><strong>解释器（Interpreter）</strong>：直接解释字节码并执行，虽然速度较慢但能快速启动。</li>
<li><strong>即时编译器（Just-In-Time Compiler, JIT）</strong>：将经常执行的字节码编译成本地机器代码以提高执行效率。</li>
<li><strong>垃圾收集器（Garbage Collector, GC）</strong>：自动管理内存，回收不再使用的对象所占用的内存空间。</li>
</ul>
<h3><span id="本地接口库native-interface-library">本地接口库（Native Interface Library）：</span></h3><p>提供了一种机制，<strong>允许Java代码调用C&#x2F;C++等其他语言编写的本地库函数</strong>，这通过JNI（Java Native Interface）实现。</p>
<h3><span id="本地方法库native-method-library">本地方法库（Native Method Library）：</span></h3><p>包含了由本地代码（如C&#x2F;C++）实现的方法库，这些方法可以通过JNI被Java程序调用。</p>
<hr>
<h1><span id="运行时数据区">运行时数据区</span></h1><p>JVM再执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p>
<h2><span id="分类">分类：</span></h2><h3><span id="程序计数器program-counter-register">程序计数器（Program Counter Register）：</span></h3><ul>
<li>每个线程都有一个独立的程序计数器。</li>
<li><strong>存储当前线程正在执行的字节码指令的地址</strong>。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地方法（Native Method），则计数器的值为空（Undefined）。</li>
</ul>
<h3><span id="虚拟机栈java-virtual-machine-stacks">虚拟机栈（Java Virtual Machine Stacks）：</span></h3><p><strong>存储方法调用过程中的局部变量、操作数栈、动态链接和方法出口信息。</strong></p>
<h3><span id><img src="/./../images/5e0f60d1c2ba4cea951af5d057fef3a3.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></span></h3><p>每个线程在创建时都会创建一个私有的栈。<br> 栈由多个栈帧（Frame）组成，每个栈帧对应一个方法调用。</p>
<ul>
<li><strong>局部变量表（Local Variable Table）：</strong>存储方法参数和方法内部定义的局部变量。包括各种基本数据类型、对象引用和返回地址类型。</li>
<li><strong>操作数栈（Operand Stack）：</strong>用于存储计算过程中需要的操作数和结果。Java虚拟机的指令集大多通过操作数栈来进行计算。</li>
<li><strong>动态链接（Dynamic Linking）：</strong>指向运行时常量池中的符号引用，这些引用在类加载阶段解析为直接引用后，可以通过这些引用访问类或接口的方法和字段。</li>
<li><strong>方法出口信息（Return Address）：</strong>存储方法返回地址，即方法退出后应该返回到的位置。</li>
</ul>
<h3><span id="堆heap">堆（Heap）：</span></h3><h3><span id><img src="/./../images/49ccf263893f4ffa97c82a2eafa1403c.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></span></h3><ul>
<li>堆是所有线程共享的一块内存区域，主要用于<strong>存储对象实例和数组</strong>。</li>
<li>堆被划分为<strong>新生代（Young Generation）、老年代（Old Generation）</strong>等不同区域，以实现高效的垃圾回收机制。</li>
<li><strong>新生代通常进一步分为Eden区和两个Survivor区（From和To）</strong>，用于管理新创建的对象。</li>
</ul>
<p><strong>注意:</strong></p>
<p>在早期的Java虚拟机（JVM）实现中，存在一个被称为“永久代”（Permanent Generation，简称PermGen）的区域，它用于存储类的元数据。然而，从Java 8开始，JVM的设计发生了变化，永久代被移除，并引入了一个新的区域叫做“元空间”（Metaspace）</p>
<p><strong>永久代是堆的一部分，与永久代不同，元空间并不属于堆内存，而是直接分配在本地内存（Native Memory）中。</strong></p>
<h3><span id="方法区method-area">方法区（Method Area）：</span></h3><p>方法区也是所有线程共享的一块内存区域，用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等</strong>。</p>
<ul>
<li><strong>类信息：</strong>包括类的名称、父类名称、实现的接口列表、字段描述符、方法描述符等。</li>
<li><strong>常量池</strong>（Constant Pool）：存储了类或接口中定义的常量，如字符串常量、整型常量等。</li>
<li><strong>静态变量</strong>（Static Variables）：存储类级别的变量，这些变量属于整个类而非某个实例。</li>
<li><strong>即时编译器编译后的代码缓存</strong>：存储由JIT编译器生成的机器码。</li>
</ul>
<h3><span id="本地方法栈native-method-stack">本地方法栈（Native Method Stack）：</span></h3><ul>
<li>与虚拟机栈类似，但专门为执行本地方法（Native Method）服务。</li>
<li>存储本地方法调用时的相关信息，具体结构和功能依赖于本地方法的具体实现。</li>
</ul>
<hr>
<h1><span id="类加载器">类加载器</span></h1><p><img src="/./../images/fbd33249a10a4833911eb24d9cebafc7.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<h2><span id="类加载机制">类加载机制</span></h2><p>​    虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<p>​     Java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<h3><span id="类的生命周期">类的生命周期：</span></h3><p>类的生命周期是指从类被加载到JVM中开始，直到最终被卸载的过程。这个过程可以分为几个主要阶段：<strong>加载（Loading）、链接（Linking）、初始化（Initialization）、使用（Using）和卸载（Unloading）。</strong></p>
<p>类的加载阶段必须按顺序执行，而解析阶段不一定。</p>
<p><strong>有四种情况必须立即对类进行“初始化”：</strong></p>
<blockquote>
<ol>
<li>使用 new 关键字实例化对象</li>
</ol>
<p> 当你使用 new 关键字创建一个类的实例时，如果该类尚未被初始化，则会触发类的初始化。</p>
<ol start="2">
<li>调用类的静态方法</li>
</ol>
<p> 当你调用一个类的静态方法时，如果该类尚未被初始化，则会触发类的初始化。</p>
<ol start="3">
<li>访问或设置类的静态字段（非final）</li>
</ol>
<p> 当你访问或设置一个类的静态字段（且该字段不是 final 的）时，如果该类尚未被初始化，则会触发类的初始化。</p>
<ol start="4">
<li>使用反射机制</li>
</ol>
<p> 当你通过反射机制来操作类时，某些操作会触发类的初始化。例如，使用 Class.forName(String name) 方法加载类时，如果该类尚未被初始化，则会触发其初始化过程。 </p>
</blockquote>
<p><img src="/./../images/c01191e6335e486fbb8eeaa32e528f7b.jpeg" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<h4><span id="1-加载loading">1. 加载（Loading）</span></h4><p>目标：<strong>找到类的字节码文件，并将其加载到内存中。</strong></p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>创建类对象，在Java堆中生成一个代表这个类的java.lang.Class对象（实例化），作为方法区这些数据的访问入口。</li>
</ul>
<h4><span id="2-链接linking">2. 链接（Linking）</span></h4><p>链接阶段又可以细分为三个子阶段：<strong>验证（Verification）、准备（Preparation）和解析（Resolution）。</strong></p>
<h5><span id="21-验证verification">2.1 验证（Verification）</span></h5><p>目标：<strong>确保类的字节码是正确且安全的。</strong></p>
<ul>
<li>文件格式验证：验证字节码是否符合Java虚拟机规范的文件格式要求。</li>
<li>元数据验证：确保类的结构是正确的，例如方法是否有返回值、继承关系是否合法等。</li>
<li>字节码验证：防止恶意代码对系统的攻击，确保字节码在运行时是安全的。</li>
<li>.符号引用验证：确保符号引用能够正确解析为直接引用。（解析阶段发生）</li>
</ul>
<h5><span id="22-准备preparation">2.2 准备（Preparation）</span></h5><p>目标：<strong>为类的静态变量分配内存，并设置默认初始值。</strong></p>
<ul>
<li>静态变量初始化：在这个阶段，所有静态变量都会被分配内存空间，并赋予默认值（例如 int 类型的默认值为 0，Object 类型的默认值为 null）。</li>
</ul>
<h5><span id="23-解析resolution">2.3 解析（Resolution）</span></h5><p>目标：<strong>将类、接口、字段和方法的符号引用转换为直接引用。</strong></p>
<ul>
<li>符号引用：在编译时生成的对其他类、接口、字段或方法的引用。</li>
<li>直接引用：在运行时解析这些符号引用，找到它们实际的内存地址。</li>
</ul>
<h4><span id="3-初始化initialization">3. 初始化（Initialization）</span></h4><p>目标：<strong>执行类的静态初始化块和静态变量的赋值操作。</strong></p>
<ul>
<li>静态初始化块：如果类中有静态初始化块（static {}），这些块会在初始化阶段被执行。</li>
<li>静态变量赋值：静态变量会被赋予程序员指定的初始值（而不是默认值）。</li>
</ul>
<h4><span id="4-使用using">4. 使用（Using）</span></h4><p>目标：<strong>当类被加载、链接和初始化后，就可以在程序中使用了。</strong></p>
<ul>
<li>实例化对象：通过 new 关键字创建类的实例。</li>
<li>调用方法：可以调用类的方法或访问类的字段。</li>
</ul>
<h4><span id="5-卸载unloading">5. 卸载（Unloading）</span></h4><p>目标：<strong>当类不再被使用时，JVM会进行垃圾回收，释放相关的资源。</strong></p>
<ul>
<li>类卸载条件：只有当类加载器本身也被垃圾回收时，类才会被卸载。具体来说，当没有任何对象引用类加载器时，类加载器及其加载的所有类都可以被垃圾回收。</li>
</ul>
<h3><span id="类生命周期的详细步骤">类生命周期的详细步骤</span></h3><blockquote>
<p><strong>1.加载（Loading）：</strong></p>
<ul>
<li>查找并读取 .class 文件。</li>
<li>创建 java.lang.Class 对象表示该类。</li>
</ul>
<p><strong>2.链接（Linking）：</strong></p>
<ul>
<li>验证（Verification）：检查字节码的正确性和安全性。</li>
<li>准备（Preparation）：为静态变量分配内存并赋予默认值。</li>
<li>解析（Resolution）：将符号引用解析为直接引用。</li>
</ul>
<p><strong>3.初始化（Initialization）：</strong></p>
<ul>
<li>执行静态初始化块和静态变量的赋值操作。</li>
</ul>
<p><strong>4.使用（Using）：</strong></p>
<ul>
<li>实例化对象并调用类的方法。</li>
</ul>
<p><strong>5.卸载（Unloading）：</strong></p>
<ul>
<li>当类加载器不再被引用时，JVM可能会卸载类及其相关资源。</li>
</ul>
</blockquote>
<h2><span id="类加载器的层次">类加载器的层次：</span></h2><p>​    比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即时这两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h3><span id="启动类加载器bootstrap-classloader">启动类加载器（Bootstrap ClassLoader）</span></h3><ul>
<li>这是最顶层的类加载器，由本地代码实现（通常是C&#x2F;C++），不属于Java类层次结构的一部分。</li>
<li>负责加载核心Java库中的类，例如 rt.jar 中的类，这些类位于 $JAVA_HOME&#x2F;jre&#x2F;lib 目录下。</li>
<li>由于它是由本地代码实现的，因此无法通过Java代码直接访问或扩展。</li>
</ul>
<h3><span id="扩展类加载器extension-classloader">扩展类加载器（Extension ClassLoader）</span></h3><ul>
<li>继承自 java.net.URLClassLoader，是 sun.misc.Launcher$ExtClassLoader 的实例。</li>
<li>负责加载位于 $JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 目录下的扩展类库，以及任何配置在 java.ext.dirs 系统属性中的路径中的类库。</li>
</ul>
<h3><span id="应用类加载器application-classloader">应用类加载器（Application ClassLoader）</span></h3><ul>
<li>继承自 java.net.URLClassLoader，是 sun.misc.Launcher$AppClassLoader 的实例。</li>
<li>负责加载应用程序类路径上的类，即 -classpath 或 CLASSPATH 环境变量指定的路径中的类。</li>
</ul>
<h3><span id="自定义类加载器custom-classloader">自定义类加载器（Custom ClassLoader）</span></h3><ul>
<li>用户可以继承 java.lang.ClassLoader 来创建自定义类加载器，以满足特定需求，如从数据库、网络或其他非标准位置加载类。</li>
</ul>
<h2><span id="双亲委派模型">双亲委派模型</span></h2><p><img src="/./../images/3c487179cf174c33a5f6c3de84af739e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<p>类加载器使用双亲委派模型（Parent Delegation Model），其工作原理如下：</p>
<ol>
<li>当一个类加载器收到加载某个类的请求时，首先不会自己去尝试加载这个类。</li>
<li>它会将该请求<strong>委派给它的父类加载器，直到启动类加载器</strong>。</li>
<li>如果<strong>父类加载器无法找到或加载该类，则子类加载器才会尝试自己加载该类</strong>。</li>
<li>如果所有父类加载器都无法加载该类，则最终会抛出 ClassNotFoundException 异常。</li>
</ol>
<hr>
<h1><span id="垃圾收集器">垃圾收集器</span></h1><h2><span id="垃圾收集是什么">垃圾收集是什么？</span></h2><blockquote>
<p>​    是Java虚拟机（JVM）自动管理内存的一种机制，目的是自动释放不再使用的对象所占用的内存资源。</p>
</blockquote>
<h2><span id="为什么要垃圾收集">为什么要垃圾收集？</span></h2><blockquote>
<p><strong>1.防止内存泄漏：</strong></p>
<ul>
<li>如果程序中存在不再使用的对象但仍然持有对这些对象的引用，那么这些对象将无法被释放，导致内存泄漏。内存泄漏会逐渐耗尽可用内存，最终导致应用程序崩溃或性能下降。</li>
</ul>
<p><strong>2.简化内存管理：</strong></p>
<ul>
<li>在没有垃圾回收的语言中，开发者需要手动管理内存分配和释放。这不仅增加了开发复杂度，还容易出错。通过垃圾回收，开发者可以专注于业务逻辑，而无需担心内存管理问题。</li>
</ul>
<p><strong>3.提高系统稳定性：</strong></p>
<ul>
<li>自动化的垃圾回收可以确保在适当的时候释放内存，从而减少因内存不足导致的应用崩溃或性能问题。</li>
</ul>
<p><strong>4.优化内存使用：</strong></p>
<ul>
<li>垃圾回收器可以通过压缩等方式重新组织堆内存，减少内存碎片化，提高内存利用率。</li>
</ul>
</blockquote>
<h2><span id="垃圾收集发生在哪里">垃圾收集发生在哪里？</span></h2><p><img src="/./../images/49ccf263893f4ffa97c82a2eafa1403c.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<blockquote>
<p>垃圾回收<strong>主要发生在堆内存</strong>（Heap Memory） 中，因为堆是存储对象实例的地方。具体来说：</p>
<ul>
<li><strong>年轻代（Young Generation）：</strong>新创建的对象首先被分配到年轻代中的Eden区。<strong>当Eden区满时，会触发一次Minor GC（轻量级垃圾回收）</strong>，清理掉不再使用的对象，并将存活的对象移动到Survivor区。</li>
<li><strong>老年代（Old Generation）：</strong>经过多次Minor GC后仍存活的对象会被晋升到老年代。老年代的空间较大，通常用于存储生命周期较长的对象。<strong>当老年代空间不足时，会触发Major GC或Full GC（全量垃圾回收）</strong>。</li>
<li><strong>永久代&#x2F;元空间（Permanent Generation&#x2F;Metaspace）：</strong>从Java 8开始，永久代被元空间取代。元空间用于存储类的元数据、方法信息等。虽然这部分不属于堆内存，但它也是垃圾回收的一部分，尤其是类卸载时。（逻辑上存在于堆，物理上不存在）</li>
</ul>
</blockquote>
<h2><span id="垃圾收集的流程">垃圾收集的流程</span></h2><p> 堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要<strong>确定哪些对象还“存活”着，哪些已经“死去”</strong>(即不可能再被任何途径使用的对象)。</p>
<h3><span id="1判断对象是否存活"><strong>1.判断对象是否存活</strong></span></h3><h4><span id="1引用计数算法">（1）引用计数算法</span></h4><blockquote>
<p>​    给对象中添加一个引用计数。每当有一个地方引用它，计数器就加1；当引用失效，计数器值就减1。<strong>任何时候，计数器值为0的对象就是不可能被使用的。</strong></p>
</blockquote>
<p><strong>注意：</strong>Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它<strong>很难解决对象之间的相互循环引用的问题</strong>。</p>
<h4><span id="2根搜索算法">（2）根搜索算法</span></h4><p>​    在主流的商用程序语言中（Java 和 C#， 甚至包括古老的Lisp），都是采用根搜索算法（GC Roots Tracing）判定对象是否存活。</p>
<blockquote>
<p>​    通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为<strong>引用链</strong>，当一个对象到GC Roots没有任何的引用链相连（用图论的话来说就是从GC Roots到这个对象不可达），则证明此对象是不可用的。</p>
</blockquote>
<p><img src="/./../images/37d6f7b6357441c18cb7092ebd7a2733.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<blockquote>
<p> 无论是引用计数算法还是根搜索算法都离不开<strong>“引用”</strong>：</p>
<ul>
<li>强引用：常规引用，对象不会被回收。</li>
<li>软引用：内存不足时可能被回收，用于缓存。</li>
<li>弱引用：对象无强引用时立即被回收，用于生命周期较短的对象。</li>
<li>虚引用：跟踪对象回收状态，用于清理操作。</li>
</ul>
</blockquote>
<h3><span id="2垃圾收集算法">2.垃圾收集算法</span></h3><h4><span id="1标记-清除算法">（1）标记-清除算法</span></h4><p><img src="/./../images/63cedbf72c824b7098e5df51ca566c77.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<blockquote>
<p><strong>原理</strong></p>
<ul>
<li>标记阶段：从根对象开始，递归地遍历所有可达的对象，并将这些对象标记为存活。</li>
<li>清除阶段：扫描整个堆内存，清理未被标记的对象，释放其占用的内存。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>实现简单，不需要额外的空间。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>容易产生内存碎片，影响后续的大对象分配。</li>
<li>需要暂停应用程序（Stop-the-world），影响系统的响应时间。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>适用于对停顿时间要求不高、内存碎片化问题不严重的场景。</li>
</ul>
</blockquote>
<h4><span id="2复制算法">（2）复制算法</span></h4><p><img src="/./../images/09173714d72c442c8b794b2191dc6f7f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<blockquote>
<p><strong>原理</strong></p>
<ul>
<li>将堆内存分为两个区域（Eden区和Survivor区），每次只使用其中一个区域。</li>
<li>当一个区域满时，触发GC，将存活的对象复制到另一个区域，然后清空当前区域。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>不会产生内存碎片，适合处理短期存在的对象。</li>
<li>清理过程高效，只需移动存活对象。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要额外的空间来存储存活的对象，内存利用率较低。</li>
<li>每次GC都需要复制对象，增加了开销。</li>
</ul>
</blockquote>
<h4><span id="3标记-整理算法">（3）标记-整理算法</span></h4><p><img src="/./../images/c6d4e8f834224968bed0d522a4c5974d.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> </p>
<blockquote>
<p><strong>原理</strong></p>
<ul>
<li>类似于标记-清除算法，但在清除阶段会将存活的对象向一端移动，从而避免内存碎片。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>解决了内存碎片问题，适合处理长期存在的对象。</li>
<li>内存利用率较高。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>移动对象的过程较为耗时，可能导致暂停时间较长。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>适用于老年代（Old Generation）的垃圾回收，特别是当内存碎片化成为问题时。</li>
</ul>
</blockquote>
<h4><span id="4分代收集算法">（4）分代收集算法</span></h4><blockquote>
<p><strong>原理</strong></p>
<ul>
<li>根据对象的生命周期将其分为年轻代和老年代。</li>
<li><strong>年轻代采用复制算法，老年代采用标记-清除或标记-整理算法。</strong></li>
<li>通过这种分代策略，可以更高效地管理不同生命周期的对象。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>提高了垃圾回收的效率，减少了不必要的扫描。</li>
<li>针对不同生命周期的对象采用了不同的回收策略。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>实现复杂，需要维护多个区域的状态。</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>适用于大多数现代JVM，默认配置通常使用分代收集算法。</li>
</ul>
</blockquote>
<hr>
<h2><span id="内存分配与回收策略">内存分配与回收策略</span></h2><h3><span id="内存分配">内存分配</span></h3><h4><span id="1-堆内存划分">1. 堆内存划分</span></h4><p>JVM的堆内存通常被划分为以下几个区域：</p>
<blockquote>
<p><strong>年轻代（Young Generation）：</strong>新创建的对象首先被分配到年轻代。</p>
<ul>
<li>Eden区：新对象通常首先被分配到这里。</li>
<li>Survivor区（S0 和 S1）：用于存放从Eden区存活下来的对象。</li>
</ul>
<p><strong>老年代（Old Generation）：</strong></p>
<ul>
<li>经过多次Minor GC后仍存活的对象会被晋升到老年代。</li>
</ul>
<p><strong>永久代&#x2F;元空间（Permanent Generation&#x2F;Metaspace）：</strong></p>
<ul>
<li>存储类的元数据、方法信息等（从Java 8开始，永久代被元空间取代）。</li>
</ul>
</blockquote>
<h4><span id="2-对象分配">2. 对象分配</span></h4><blockquote>
<p><strong>年轻代分配：</strong></p>
<ul>
<li>新对象通常首先被分配到Eden区。</li>
<li>如果Eden区空间不足，会触发一次Minor GC，清理掉不再使用的对象，并将存活的对象移动到Survivor区。</li>
</ul>
<p><strong>老年代分配：</strong></p>
<ul>
<li><strong>经过多次Minor GC后仍存活的对象会被晋升到老年代。</strong></li>
<li>对于<strong>大对象（超过一定阈值）</strong>，可以直接分配到老年代（通过-XX:PretenureSizeThreshold参数设置阈值）。</li>
</ul>
</blockquote>
<h4><span id="3-tlabthread-local-allocation-buffer">3. TLAB（Thread Local Allocation Buffer）</span></h4><blockquote>
<p>​    为了提高多线程环境下的对象分配效率，JVM为每个线程分配了一个本地缓冲区（TLAB）。当线程需要分配对象时，优先从TLAB中分配内存，减少了线程间的竞争。</p>
</blockquote>
<h3><span id="回收策略">回收策略</span></h3><h4><span id="1-minor-gc轻量级垃圾回收">1. Minor GC（轻量级垃圾回收）</span></h4><blockquote>
<p><strong>触发条件：****Eden区满时触发。</strong><br> <strong>过程：</strong></p>
<ul>
<li>标记Eden区和Survivor区中的存活对象。</li>
<li>将存活对象复制到另一个Survivor区（例如从S0复制到S1）。</li>
<li>清理Eden区和原来的Survivor区。</li>
<li>如果某个对象经过多次Minor GC仍然存活，则将其晋升到老年代。</li>
</ul>
</blockquote>
<h4><span id="2-major-gc重量级垃圾回收">2. Major GC（重量级垃圾回收）</span></h4><blockquote>
<p><strong>触发条件：****老年代空间不足时触发。</strong><br> <strong>过程：</strong></p>
<ul>
<li>标记老年代中的存活对象。</li>
<li>清理未被标记的对象，释放其占用的内存。</li>
<li>可能会进行内存整理，减少碎片化。</li>
</ul>
</blockquote>
<h4><span id="3-full-gc全量垃圾回收">3. Full GC（全量垃圾回收）</span></h4><blockquote>
<p><strong>触发条件：****整个堆内存</strong>（包括年轻代和老年代）<strong>空间不足时触发。</strong><br> <strong>过程：</strong></p>
<ul>
<li>标记并清理年轻代和老年代中的所有对象。</li>
<li>清理元空间中的无效类信息（如果使用了G1或ZGC等收集器）。</li>
</ul>
</blockquote>
<hr>
<h1><span id="执行引擎">执行引擎</span></h1><p> JVM（Java虚拟机）的执行引擎是<strong>负责执行字节码</strong>的核心组件。它将编译器生成的Java字节码转换为具体平台上的机器码，并在运行时管理这些代码的执行。执行引擎的主要职责包括解释字节码、即时编译（JIT）、垃圾回收等。以下是JVM执行引擎的关键组成部分和工作机制。</p>
<h2><span id="基本组成">基本组成</span></h2><h3><span id="解释器interpreter">解释器（Interpreter）</span></h3><blockquote>
<p><strong>功能</strong>：逐条读取并解释执行Java字节码。<br> <strong>优点：</strong></p>
<ul>
<li>启动速度快，因为不需要预编译。</li>
<li>适合短生命周期的应用程序。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>执行效率较低，因为每次都需要重新解释字节码。</li>
</ul>
</blockquote>
<h3><span id="即时编译器just-in-time-compiler-jit">即时编译器（Just-In-Time Compiler, JIT）</span></h3><blockquote>
<p><strong>功能：</strong>将频繁执行的字节码片段编译成本地机器码，以提高执行效率。<br> <strong>工作原理：</strong></p>
<ul>
<li>在程序运行过程中，JIT会识别出“热点”方法（即经常被调用的方法），并将它们编译成本地机器码。</li>
<li>编译后的机器码可以直接由CPU执行，减少了解释执行的开销。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>提高了频繁执行代码段的性能。</li>
<li>动态优化，适应不同的运行环境。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初始启动时间较长，因为需要进行编译。</li>
<li>需要占用额外的内存来存储编译后的机器码。</li>
</ul>
</blockquote>
<h3><span id="垃圾回收器garbage-collector-gc">垃圾回收器（Garbage Collector, GC）</span></h3><blockquote>
<p><strong>功能：</strong>自动管理内存，回收不再使用的对象，释放内存资源。<br> <strong>常见GC算法：</strong></p>
<ul>
<li>Serial收集器：单线程执行，适用于单核CPU和对响应时间要求不高的应用。</li>
<li>Parallel收集器：多线程并行执行，适用于吞吐量优先的应用。</li>
<li>CMS（Concurrent Mark-Sweep）收集器：并发执行，减少停顿时间，适用于对响应时间要求较高的应用。</li>
<li>G1收集器：面向服务端应用，可设置停顿时间目标，适合需要低延迟的应用。</li>
<li>ZGC收集器：极低的暂停时间，适合大规模应用和大堆内存。</li>
</ul>
</blockquote>
<h2><span id="工作流程">工作流程</span></h2><h3><span id="1加载字节码">1.加载字节码：</span></h3><ul>
<li>类加载器（ClassLoader）将 .class 文件加载到JVM中，并将其转换为方法区中的类数据结构。</li>
</ul>
<h3><span id="2-链接linking">2. 链接（Linking）：</span></h3><ul>
<li>验证（Verification）：确保加载的字节码符合JVM规范，防止恶意代码或错误代码的执行。</li>
<li>准备（Preparation）：为类的静态变量分配内存，并设置默认初始值。</li>
<li>解析（Resolution）：将类、接口、字段和方法的符号引用转换为直接引用。</li>
</ul>
<h3><span id="3初始化initialization">3.初始化（Initialization）：</span></h3><ul>
<li>执行类构造器 <clinit> 方法，为静态变量赋初始值，并执行静态初始化块中的代码。</clinit></li>
</ul>
<h3><span id="4执行字节码">4.执行字节码：</span></h3><ul>
<li>解释器逐条解释执行字节码指令。</li>
<li>对于频繁执行的代码段，JIT编译器将其编译成本地机器码，以提高执行效率。</li>
</ul>
<h3><span id="5垃圾回收">5.垃圾回收：</span></h3><ul>
<li>当堆内存不足时，垃圾回收器会触发垃圾回收，清理不再使用的对象，释放内存资源。</li>
</ul>
<h2><span id="优化技术">优化技术</span></h2><p>VM执行引擎的优化技术旨在提升Java应用程序的执行效率和性能。这些技术包括但不限于：</p>
<ul>
<li>分层编译：结合解释器和JIT的优势，提供渐进式的编译优化。</li>
<li>内联：将方法调用替换为方法体本身，减少方法调用的开销。</li>
<li>逃逸分析：分析对象的作用域，决定是否栈上分配以减少垃圾回收开销。</li>
<li>锁优化：减少锁竞争，提高并发性能。</li>
<li>分支预测：提高条件语句的执行效率。</li>
<li>方法内联缓存：提高动态方法调用的效率。</li>
<li>常量折叠：在编译期间计算常量表达式的结果。</li>
<li>死代码消除：移除不会被执行的代码段。</li>
<li>循环展开：通过增加每次迭代处理的数据量，减少循环控制的开销。</li>
</ul>
<hr>
<h1><span id="补充">补充 ：</span></h1><p>JVM调优：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40991313/article/details/132382094?ops_request_misc=%7B%22request_id%22:%22c7f9ea2322a06ee2ecc7b1b9b7bc46bc%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=c7f9ea2322a06ee2ecc7b1b9b7bc46bc&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-132382094-null-null.142%5Ev102%5Epc_search_result_base7&utm_term=jvm%E8%B0%83%E4%BC%98&spm=1018.2226.3001.4187">JVM调优</a></p>
<p>JMM（内存模型）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25409421/article/details/131273163?ops_request_misc=%7B%22request_id%22:%22ec0000f3394d64b433b8213f739b94ae%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=ec0000f3394d64b433b8213f739b94ae&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-131273163-null-null.142%5Ev102%5Epc_search_result_base7&utm_term=JMM&spm=1018.2226.3001.4187">Java内存模型JMM</a></p>
<hr>
<p> <strong>注意：</strong></p>
<p><strong>1.本篇文章中的图片来源于百度（侵删）</strong></p>
<p><strong>2.如有错误，欢迎指正。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://xuanskeys.github.io">xuanskeys</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://xuanskeys.github.io/2025/04/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">http://xuanskeys.github.io/2025/04/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://xuanskeys.github.io" target="_blank">XuanCode</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/1/">1</a></div><div class="post-share"><div class="social-share" data-image="/image/person.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/20/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="基础算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">基础算法</div></div><div class="info-2"><div class="info-item-1">快速排序图解分析：  模板：12345678910111213141516171819202122//核心思想：分而治之//函数参数：(需要处理的数组， 数组的左边界， 数组的右边界)//函数：使得左边小于x, 右边大于x void quick_sort(int q[], int l, int r)&#123;    //递归出口    if (l &gt;= r) return;        //运用双指针，左指针指向的数小于x, 右指针指向的数大于x    int x = (q[l] + q[r]) / 2;    int i = l - 1, j = r + 1;    while (i &lt; j)    &#123;        do i ++; while(q[i] &lt; x);        do j --; while(q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    &#125;        //递归处理左右子区间    quick_sort(q, l, j);   ...</div></div></div></a><a class="pagination-related" href="/2025/04/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/" title="最短路问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">最短路问题</div></div><div class="info-2"><div class="info-item-1">学习思路（yxc总结）： 一. 朴素Dijkstra算法 (稠密图)****&lt;邻接矩阵&gt;算法思路： 更新过程：acwing849. Dijkstra求最短路 I  此题思路（分解版）： 1.读入的同时需要更新边权 1g[a][b] = min(g[a][b], c);//g[][]存放的为最小边权   2.Dijkstra算法 (核心步骤)，循环思路对应朴素Dijkstra算法的第二步 123456789101112for (int i = 0; i &lt; n; i ++ )//循环每一个点&#123;       int t = -1;//初始化       for (int j = 1; j &lt;= n; j ++ )           if (!st[j] &amp;&amp; (t == -1 || d[t] &gt; d[j]))//没有确定最短距离的点 + 没有更新过t/距离更近的点               t = j;                      st[t] = true;//标记t这个点已确定最短距离           ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/21/CentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="CentOS 7环境搭建"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-21</div><div class="info-item-2">CentOS 7环境搭建</div></div><div class="info-2"><div class="info-item-1">CentOS 7环境搭建我的基础环境：  CentOS版本：CentOS Linux release 7.7.1908 (Core) Vmware版本：VMware® Workstation 17 Pro 17.5.0 build-22583795   注意：  所有有关防火墙的操作都可以不开端口，但是我为了测试方便我就开了端口号，便于后续本地测试，这个自行选择。 我所有的安装指令都是在root用户权限下执行的。 参考：软件安装 | CodeSheep 如有错误，欢迎指正！   1.验证网络连通性12ping 8.8.8.8ping www.baidu.com   连不通的，去修改一下&#x2F;etc&#x2F;resolv.conf下的dns配置 12345# /etc/resolv.confnameserver 223.5.5.5      # 阿里云主DNSnameserver 223.6.6.6      # 阿里云备DNSnameserver 114.114.114.114 # 114公共DNS（备用）nameserver 8.8.8.8        #...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC2/" title="Java并发编程2(锁-Sychronized)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java并发编程2(锁-Sychronized)</div></div><div class="info-2"><div class="info-item-1">认识Java对象头  32位虚拟机对象头：   64位虚拟机对象头：     1.Mark Word（标记字）:  Mark Word是对象头的一部分，用于存储对象自身的哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID（或偏向时间戳）、偏向模式以及锁的状态等信息。 标记字的大小和具体内容可能因JVM实现的不同而有所变化。例如，在64位JVM上，默认情况下Mark Word占用64位（8字节），而在32位JVM上则是32位（4字节）。  2.Class Pointer（类指针）:  这是指向该对象对应类（Class）的指针，通过这个指针可以访问到对象所属类的元数据（如方法表、字段描述等）。类指针的大小依赖于JVM的具体实现及其是否开启了压缩指针（Compressed Oop）选项。 在某些情况下，比如当使用了-XX:+UseCompressedClassPointers选项时，类指针会被压缩以节省内存。  3.Array...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC1/" title="JUC并发编程1(初识进程和线程)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">JUC并发编程1(初识进程和线程)</div></div><div class="info-2"><div class="info-item-1"> 初识进程和线程初识进程：定义：  进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。（百度百科） 进程由程序、数据和进程控制块三部分组成。   什么是进程？ 狭义定义：进程是正在运行的程序的实例。 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。   eg：进程可以看做是程序的实例，你可以打开多个程序，每一个程序就是一个进程（比如你重复打开QQ登录不同的用户，每一个用户登录的那个程序就是一个进程）。   如果你关闭一个窗口，那么这个进程也就结束了  概念：1.进程是一个实体。 ...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC3/" title="Java并发编程3(CAS)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java并发编程3(CAS)</div></div><div class="info-2"><div class="info-item-1">Java内存模型(JMM)概念百度百科：java内存模型_百度百科  Java内存模型（Java Memory Model,...</div></div></div></a><a class="pagination-related" href="/2025/04/27/JavaScript/" title="JavaScript"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">JavaScript</div></div><div class="info-2"><div class="info-item-1">JavaScriptJavaScript是什么? JavaScript 是脚本语言  JavaScript 是一种轻量级的编程语言。  JavaScript 是可插入 HTML 页面的编程代码。  JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。   怎么定义？HTML 中的 Javascript 脚本代码必须位于  与  标签之间。 Javascript 脚本代码可被放置在 HTML 页面的  和  部分中。 JS显示数据 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。  JS数据格式数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e)。 字符串（String）字面量 可以使用单引号或双引号: 表达式字面量 用于计算：5 + 6 5 * 6 数组（Array）字面量 [40, 100, 1, 5, 25, 10] 对象（Object）字面量...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC4/" title="Java并发编程4（JUC篇）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java并发编程4（JUC篇）</div></div><div class="info-2"><div class="info-item-1">本篇文章重点介绍JUC（java.util.concurrent）  JUC是”java.util.concurrent”包的简称，它是Java提供的一个并发工具包，旨在简化多线程编程，提供了丰富的类和接口来帮助开发者更高效、更安全地编写并发程序。JUC包增强了Java对并发的支持，解决了传统多线程编程中的一些难题，如死锁、竞争条件和资源管理等。    原子变量  基本类型原子变量 AtomicInteger  提供对整型值的原子操作，如加法、减法等。 方法示例：incrementAndGet(), decrementAndGet(), addAndGet(int delta), compareAndSet(int expect, int update)。  AtomicLong  类似于AtomicInteger，但是针对长整型（long）值。 方法与AtomicInteger相似，适用于需要处理较大数值的情况。  AtomicBoolean  支持布尔类型的原子操作。 方法示例：get(), set(boolean newValue),...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/person.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xuanskeys</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xuanskeys"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到XuanCode。更多详细信息请前往CSDN：https://blog.csdn.net/m0_73569492?type=blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">JVM的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.0.1.</span> <span class="toc-text">什么是虚拟机？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.0.2.</span> <span class="toc-text">为什么要有JVM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.0.3.</span> <span class="toc-text">什么是java虚拟机?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">JVM的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.1.</span> <span class="toc-text">类加载器（ClassLoader）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.2.</span> <span class="toc-text">运行时数据区（Runtime Data Area）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.3.</span> <span class="toc-text">执行引擎（Execution Engine）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.4.</span> <span class="toc-text">本地接口库（Native Interface Library）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.5.</span> <span class="toc-text">本地方法库（Native Method Library）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">分类：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.1.</span> <span class="toc-text">程序计数器（Program Counter Register）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.2.</span> <span class="toc-text">虚拟机栈（Java Virtual Machine Stacks）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.4.</span> <span class="toc-text">堆（Heap）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.5.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.6.</span> <span class="toc-text">方法区（Method Area）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.7.</span> <span class="toc-text">本地方法栈（Native Method Stack）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text">类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.1.1.</span> <span class="toc-text">类的生命周期：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">1. 加载（Loading）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">2. 链接（Linking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text">2.1 验证（Verification）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">4.1.1.2.2.</span> <span class="toc-text">2.2 准备（Preparation）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">4.1.1.2.3.</span> <span class="toc-text">2.3 解析（Resolution）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">3. 初始化（Initialization）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">4. 使用（Using）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">5. 卸载（Unloading）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.1.2.</span> <span class="toc-text">类生命周期的详细步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.2.</span> <span class="toc-text">类加载器的层次：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.1.</span> <span class="toc-text">启动类加载器（Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.2.</span> <span class="toc-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.3.</span> <span class="toc-text">应用类加载器（Application ClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.4.</span> <span class="toc-text">自定义类加载器（Custom ClassLoader）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.3.</span> <span class="toc-text">双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.1.</span> <span class="toc-text">垃圾收集是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.2.</span> <span class="toc-text">为什么要垃圾收集？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.3.</span> <span class="toc-text">垃圾收集发生在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.4.</span> <span class="toc-text">垃圾收集的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.4.1.</span> <span class="toc-text">1.判断对象是否存活</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">（1）引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">（2）根搜索算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.4.2.</span> <span class="toc-text">2.垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">（1）标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">（2）复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">（3）标记-整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">（4）分代收集算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.5.</span> <span class="toc-text">内存分配与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.5.1.</span> <span class="toc-text">内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.5.1.1.</span> <span class="toc-text">1. 堆内存划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.5.1.2.</span> <span class="toc-text">2. 对象分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.5.1.3.</span> <span class="toc-text">3. TLAB（Thread Local Allocation Buffer）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.5.2.</span> <span class="toc-text">回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">1. Minor GC（轻量级垃圾回收）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">2. Major GC（重量级垃圾回收）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.5.2.3.</span> <span class="toc-text">3. Full GC（全量垃圾回收）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.1.</span> <span class="toc-text">基本组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.1.1.</span> <span class="toc-text">解释器（Interpreter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.1.2.</span> <span class="toc-text">即时编译器（Just-In-Time Compiler, JIT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.1.3.</span> <span class="toc-text">垃圾回收器（Garbage Collector, GC）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.2.</span> <span class="toc-text">工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.加载字节码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.2.</span> <span class="toc-text">2. 链接（Linking）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.3.</span> <span class="toc-text">3.初始化（Initialization）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.4.</span> <span class="toc-text">4.执行字节码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.5.</span> <span class="toc-text">5.垃圾回收：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.3.</span> <span class="toc-text">优化技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">补充 ：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/13/Netty/" title="Netty">Netty</a><time datetime="2025-05-13T15:15:00.000Z" title="发表于 2025-05-13 23:15:00">2025-05-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/29/Vue3/" title="无标题">无标题</a><time datetime="2025-04-29T09:51:08.718Z" title="发表于 2025-04-29 17:51:08">2025-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/JavaScript/" title="JavaScript">JavaScript</a><time datetime="2025-04-27T00:24:00.000Z" title="发表于 2025-04-27 08:24:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/26/Spring%20MVC/" title="Spring MVC">Spring MVC</a><time datetime="2025-04-26T00:24:00.000Z" title="发表于 2025-04-26 08:24:00">2025-04-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/24/WebSocket/" title="无标题">无标题</a><time datetime="2025-04-24T11:57:33.742Z" title="发表于 2025-04-24 19:57:33">2025-04-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By xuanskeys</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: 'xuanskeys.github.io',
      owner: 'xuanskeys',
      admin: ['xuanskeys'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'daeb1e5feb06c5a0768aafbdb3c52761'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>