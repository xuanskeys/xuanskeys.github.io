<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Netty | XuanCode</title><meta name="author" content="xuanskeys"><meta name="copyright" content="xuanskeys"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Nettynetty官网: https:&#x2F;&#x2F;netty.io&#x2F; 什么是Netty？ Netty 是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。 Netty 是一个 NIO 客户端服务器框架，可以快速轻松地开发网络应用程序（例如协议服务器和客户端）。它极大地简化了 TCP 和 UDP 套接字服务器等网络编程。  Java IO什么是Java IO？官方文档：h">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty">
<meta property="og:url" content="http://xuanskeys.github.io/2025/05/13/Netty/index.html">
<meta property="og:site_name" content="XuanCode">
<meta property="og:description" content="Nettynetty官网: https:&#x2F;&#x2F;netty.io&#x2F; 什么是Netty？ Netty 是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。 Netty 是一个 NIO 客户端服务器框架，可以快速轻松地开发网络应用程序（例如协议服务器和客户端）。它极大地简化了 TCP 和 UDP 套接字服务器等网络编程。  Java IO什么是Java IO？官方文档：h">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xuanskeys.github.io/image/person.jpg">
<meta property="article:published_time" content="2025-05-13T15:15:00.000Z">
<meta property="article:modified_time" content="2025-05-18T13:03:15.828Z">
<meta property="article:author" content="xuanskeys">
<meta property="article:tag" content="1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xuanskeys.github.io/image/person.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Netty",
  "url": "http://xuanskeys.github.io/2025/05/13/Netty/",
  "image": "http://xuanskeys.github.io/image/person.jpg",
  "datePublished": "2025-05-13T15:15:00.000Z",
  "dateModified": "2025-05-18T13:03:15.828Z",
  "author": [
    {
      "@type": "Person",
      "name": "xuanskeys",
      "url": "http://xuanskeys.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/%E5%AF%BF%E5%8F%B8.png"><link rel="canonical" href="http://xuanskeys.github.io/2025/05/13/Netty/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Netty',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/styles/main.css"><script src="/styles/fish.js"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/person.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">XuanCode</span></a><a class="nav-page-title" href="/"><span class="site-name">Netty</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Netty</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-13T15:15:00.000Z" title="发表于 2025-05-13 23:15:00">2025-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-18T13:03:15.828Z" title="更新于 2025-05-18 21:03:15">2025-05-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1><span id="netty">Netty</span></h1><p>netty官网: <a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io/</a></p>
<h2><span id="什么是netty">什么是Netty？</span></h2><ul>
<li>Netty 是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</li>
<li>Netty 是一个 NIO 客户端服务器框架，可以快速轻松地开发网络应用程序（例如协议服务器和客户端）。它极大地简化了 TCP 和 UDP 套接字服务器等网络编程。</li>
</ul>
<h2><span id="java-io">Java IO</span></h2><h3><span id="什么是java-io">什么是Java IO？</span></h3><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/essential/io/">https://docs.oracle.com/javase/tutorial/essential/io/</a></p>
<p><strong>I&#x2F;O（Input&#x2F;Output）</strong> 是计算机与外部设备（磁盘、网络、键盘等）进行数据交换的过程</p>
<h3><span id="分类">分类</span></h3><h4><span id="1bio-阻塞io">1.BIO (阻塞IO)</span></h4><p>每当有一个客户端与服务器进行连接，服务器就会创建一个线程去处理当前连接，当通道没有数据的时候，线程会阻塞等待</p>
<p><img src="/../images/image-20250511211425582.png" alt="image-20250511211425582"></p>
<p><img src="/../images/image-20250511215626687.png" alt="image-20250511215626687"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BioDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建服务器监听端口Socket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socketServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">3333</span>);</span><br><span class="line">        log.info(<span class="string">&quot;服务器启动成功&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> socketServer.accept();</span><br><span class="line">            log.info(<span class="string">&quot;有客户端连接了&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">            <span class="comment">// 3.创建线程处理客户端连接</span></span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    handle(socket);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理客户端连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (socket.isClosed()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 1.打印线程信息</span></span><br><span class="line">        log.info(<span class="string">&quot;线程信息：&#123;&#125;&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.读取通道数据</span></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">// 2.1 获取输入流</span></span><br><span class="line">            <span class="comment">// 2.2 读取数据</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 创建一个缓存数组</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                log.info(<span class="string">&quot;客户端发送的数据：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, read));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;客户端断开连接&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20250511215651785.png" alt="image-20250511215651785"></p>
<p><strong>文件传输</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file/test01.txt&quot;</span>);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">        randomAccessFile.read(bytes); <span class="comment">// 读取文件</span></span><br><span class="line">        <span class="comment">// 创建服务端 等待客户端连接发送文件</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">3333</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3333</span>));</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2nio-非阻塞io">2.NIO （非阻塞IO）</span></h4><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html</a></p>
<ul>
<li>NIO是面向缓冲区或者面向块编程的</li>
<li>核心组成是Selector、Channel、Buffer</li>
</ul>
<h5><span id="1channel通道">1.Channel（通道）</span></h5><ul>
<li><strong>作用</strong>：双向数据传输管道（支持读和写），替代传统 BIO 的流（Stream）。</li>
<li><strong>类型</strong>：<ul>
<li><code>SocketChannel</code>：TCP 客户端通道。</li>
<li><code>ServerSocketChannel</code>：TCP 服务端监听通道。</li>
<li><code>FileChannel</code>：文件读写通道。</li>
</ul>
</li>
</ul>
<h5><span id="2-buffer缓冲区">2. <strong>Buffer（缓冲区）</strong></span></h5><ul>
<li><p><strong>作用</strong>：数据暂存容器，减少直接操作底层数据源的次数。</p>
</li>
<li><p><strong>类型</strong>：<code>ByteBuffer</code>（最常用）、<code>CharBuffer</code>、<code>IntBuffer</code> 等。</p>
</li>
<li><p><strong>关键方法</strong>：</p>
<ul>
<li><code>put()</code>：写入数据。</li>
<li><code>get()</code>：读取数据。</li>
<li><code>flip()</code>：切换读写模式。</li>
<li><code>clear()</code>：清空缓冲区（可复用）。</li>
</ul>
<p><img src="/../images/image-20250511223235244.png" alt="image-20250511223235244"></p>
<p>Buffer类中很重要的几个字段：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标记位置，默认为-1，表示尚未设置标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前位置，用于指示当前操作的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限制位置，表示可以操作的最大位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容量，表示最大容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5><span id="3-selector选择器">3. <strong>Selector（选择器）</strong></span></h5><ul>
<li><strong>作用</strong>：单线程监听多个通道的 I&#x2F;O 事件（如连接、读、写），实现多路复用。</li>
<li><strong>核心事件</strong>：<ul>
<li><code>OP_ACCEPT</code>：服务端接收新连接。</li>
<li><code>OP_CONNECT</code>：客户端完成连接。</li>
<li><code>OP_READ</code>：数据可读。</li>
<li><code>OP_WRITE</code>：数据可写。</li>
</ul>
</li>
</ul>
<p><img src="/../images/image-20250511220614709.png" alt="image-20250511220614709"></p>
<h4><span id="3-ix2fo-多路复用">3. <strong>I&#x2F;O 多路复用</strong></span></h4><ul>
<li><strong>特点</strong>：通过 <strong>Selector&#x2F;Epoll</strong> 监控多个 I&#x2F;O 事件，当某个通道就绪时通知线程处理。</li>
<li><strong>优点</strong>：单线程高效管理多个连接，减少线程切换开销。</li>
<li><strong>核心组件</strong>：<ul>
<li><code>Selector</code>（Java NIO）</li>
<li><code>epoll</code>（Linux）</li>
<li><code>kqueue</code>（BSD）</li>
</ul>
</li>
<li><strong>应用场景</strong>：高并发服务器（如 Netty、Nginx）。</li>
</ul>
<h4><span id="4aio">4.AIO</span></h4><p><strong>异步 I&#x2F;O（Asynchronous I&#x2F;O，AIO）</strong></p>
<ul>
<li><strong>特点</strong>：线程发起 I&#x2F;O 操作后立即返回，内核负责将数据从内核缓冲区拷贝到用户缓冲区，完成后通知线程。</li>
<li><strong>优点</strong>：完全非阻塞，无轮询或等待。</li>
<li><strong>缺点</strong>：实现复杂，依赖操作系统支持（如 Linux AIO 不完善）。</li>
<li><strong>应用场景</strong>：文件操作或高吞吐场景（如 Java <code>AsynchronousFileChannel</code>）。</li>
</ul>
<h2><span id="nio">NIO</span></h2><p><img src="/./../images/image-20250512095154867.png" alt="image-20250512095154867"></p>
<h3><span id="1buffer缓冲区">1.Buffer(缓冲区)</span></h3><p><img src="/./../images/image-20250512094837223.png" alt="image-20250512094837223"></p>
<p>核心属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
<th align="left">初始值</th>
<th align="left">约束条件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>capacity</code></strong></td>
<td align="left">缓冲区的总容量（元素个数），创建时确定后不可修改。</td>
<td align="left">由 <code>allocate()</code> 或 <code>wrap()</code> 确定</td>
<td align="left"><code>capacity ≥ 0</code></td>
</tr>
<tr>
<td align="left"><strong><code>position</code></strong></td>
<td align="left">下一个要读&#x2F;写的索引位置。初始为 <code>0</code>，每读&#x2F;写一个元素递增 <code>1</code>。</td>
<td align="left"><code>0</code></td>
<td align="left"><code>0 ≤ position ≤ limit</code></td>
</tr>
<tr>
<td align="left"><strong><code>limit</code></strong></td>
<td align="left">第一个不能读&#x2F;写的索引（即读写操作的终点）。初始等于 <code>capacity</code>，可动态调整。</td>
<td align="left"><code>capacity</code></td>
<td align="left"><code>0 ≤ limit ≤ capacity</code></td>
</tr>
<tr>
<td align="left"><strong><code>mark</code></strong></td>
<td align="left">标记一个临时位置，后续可通过 <code>reset()</code> 将 <code>position</code> 恢复到此值。默认未标记（<code>-1</code>）。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>Buffer类是一个抽象类，有很多子类继承其方法完成特定数据的缓冲操作</p>
<p><img src="/./../images/image-20250512092025041.png" alt="image-20250512092025041"></p>
<p>Buffer类中包括的方法：</p>
<p><img src="/./../images/image-20250512092214379.png" alt="image-20250512092214379"></p>
<h4><span id="1核心方法">（1）核心方法：</span></h4><p>这些方法用于管理缓冲区的核心属性：<strong>容量（Capacity）</strong>、<strong>位置（Position）</strong>、<strong>限制（Limit）</strong>。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>int capacity()</code></td>
<td align="left">返回缓冲区的总容量，创建后不可修改。</td>
</tr>
<tr>
<td align="left"><code>int position()</code></td>
<td align="left">返回当前读写位置（索引）。</td>
</tr>
<tr>
<td align="left"><code>Buffer position(int p)</code></td>
<td align="left">设置当前读写位置，需满足 <code>0 ≤ p ≤ limit</code>。</td>
</tr>
<tr>
<td align="left"><code>int limit()</code></td>
<td align="left">返回缓冲区的读写限制（<code>position</code> 不能超过此值）。</td>
</tr>
<tr>
<td align="left"><code>Buffer limit(int l)</code></td>
<td align="left">设置读写限制，需满足 <code>0 ≤ l ≤ capacity</code>。</td>
</tr>
</tbody></table>
<h4><span id="2状态切换">（2）状态切换</span></h4><p>用于在<strong>读模式</strong>和<strong>写模式</strong>之间切换缓冲区的状态。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Buffer clear()</code></td>
<td align="left">重置缓冲区为写模式：<code>position=0</code>, <code>limit=capacity</code>，数据未清除，但可被覆盖。</td>
</tr>
<tr>
<td align="left"><code>Buffer flip()</code></td>
<td align="left">切换为读模式：<code>limit=position</code>, <code>position=0</code>，通常在写入数据后调用。</td>
</tr>
<tr>
<td align="left"><code>Buffer rewind()</code></td>
<td align="left">重置 <code>position=0</code>，保持 <code>limit</code> 不变，用于重新读取数据。</td>
</tr>
<tr>
<td align="left"><code>Buffer compact()</code></td>
<td align="left">（子类实现，如 <code>ByteBuffer</code>）压缩缓冲区，将未读数据移到头部，准备继续写入。</td>
</tr>
</tbody></table>
<h4><span id="3读写方法">（3）读写方法</span></h4><p>用于向缓冲区写入数据（<code>put</code>）或从缓冲区读取数据（<code>get</code>），具体方法由子类实现。</p>
<h5><span id="1-基本读写方法">1. 基本读写方法</span></h5><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ByteBuffer put(byte b)</code></td>
<td align="left">写入一个字节，<code>position</code> 递增。</td>
</tr>
<tr>
<td align="left"><code>ByteBuffer put(byte[] src)</code></td>
<td align="left">写入字节数组。</td>
</tr>
<tr>
<td align="left"><code>byte get()</code></td>
<td align="left">读取一个字节，<code>position</code> 递增。</td>
</tr>
<tr>
<td align="left"><code>ByteBuffer get(byte[] dst)</code></td>
<td align="left">读取字节到数组。</td>
</tr>
</tbody></table>
<p><img src="/./../images/image-20250512092633915.png" alt="image-20250512092633915"></p>
<h5><span id="2批量读写">2.批量读写</span></h5><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Buffer put(Buffer src)</code></td>
<td align="left">将另一个缓冲区的数据复制到当前缓冲区。</td>
</tr>
<tr>
<td align="left"><code>Buffer get(byte[] dst, int offset, int length)</code></td>
<td align="left">从缓冲区读取数据到数组的指定位置。</td>
</tr>
</tbody></table>
<h4><span id="4标记与重置">（4）<strong>标记与重置</strong></span></h4><p>用于标记和恢复 <code>position</code> 的位置。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Buffer mark()</code></td>
<td align="left">标记当前 <code>position</code>，后续可通过 <code>reset()</code> 恢复到此位置。</td>
</tr>
<tr>
<td align="left"><code>Buffer reset()</code></td>
<td align="left">将 <code>position</code> 重置到之前标记的位置。</td>
</tr>
</tbody></table>
<h4><span id="5工具方法">（5）<strong>工具方法</strong></span></h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>int remaining()</code></td>
<td align="left">返回剩余可操作的元素数量：<code>limit - position</code>。</td>
</tr>
<tr>
<td align="left"><code>boolean hasRemaining()</code></td>
<td align="left">检查是否还有剩余元素可操作（<code>position &lt; limit</code>）。</td>
</tr>
<tr>
<td align="left"><code>boolean isReadOnly()</code></td>
<td align="left">判断缓冲区是否为只读。</td>
</tr>
<tr>
<td align="left"><code>boolean isDirect()</code></td>
<td align="left">（如 <code>ByteBuffer</code>）判断是否是直接内存（堆外内存）缓冲区。</td>
</tr>
</tbody></table>
<hr>
<h4><span id="6视图与复制"><strong>（6）视图与复制</strong></span></h4><p>用于创建缓冲区的视图或副本，共享底层数据但独立维护属性。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Buffer duplicate()</code></td>
<td align="left">创建缓冲区的副本，共享数据但独立维护 <code>position</code>、<code>limit</code> 等属性。</td>
</tr>
<tr>
<td align="left"><code>Buffer slice()</code></td>
<td align="left">创建当前缓冲区的一个子视图，范围从 <code>position</code> 到 <code>limit</code>。</td>
</tr>
</tbody></table>
<h3><span id="2channel">2.Channel</span></h3><p>在 Java NIO 中，<strong>Channel（通道）</strong> 是用于在数据源（如文件、网络套接字）和缓冲区（<code>Buffer</code>）之间高效传输数据的抽象。它与传统 I&#x2F;O 的流（<code>InputStream</code>&#x2F;<code>OutputStream</code>）类似，但具有更强大的功能，如支持非阻塞模式、双向读写（部分实现）以及内存映射文件操作。</p>
<p>Channel在Java中是一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="区别channel和stream">区别（Channel和Stream）：</span></h4><p>1.Channel可以同时进行读写，流只能读或写</p>
<p>2.通道可以实现异步读写</p>
<p>3。通道可以写数据到缓冲区，也可以从缓冲区读数据</p>
<h4><span id="实现子类">实现子类：</span></h4><p><img src="/./../images/image-20250512095859173.png" alt="image-20250512095859173"></p>
<table>
<thead>
<tr>
<th align="left"><strong>Channel 子类</strong></th>
<th align="left"><strong>应用场景</strong></th>
<th align="left"><strong>关键特性</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FileChannel</code></td>
<td align="left">文件读写</td>
<td align="left">内存映射、零拷贝传输</td>
</tr>
<tr>
<td align="left"><code>SocketChannel</code></td>
<td align="left">TCP 客户端通信</td>
<td align="left">非阻塞模式、Selector 多路复用</td>
</tr>
<tr>
<td align="left"><code>ServerSocketChannel</code></td>
<td align="left">TCP 服务端监听</td>
<td align="left">接受客户端连接</td>
</tr>
<tr>
<td align="left"><code>DatagramChannel</code></td>
<td align="left">UDP 数据报通信</td>
<td align="left">无连接、支持广播</td>
</tr>
<tr>
<td align="left"><code>Pipe.Source/SinkChannel</code></td>
<td align="left">线程间通信</td>
<td align="left">单向数据传输</td>
</tr>
<tr>
<td align="left"><code>AsynchronousFileChannel</code></td>
<td align="left">异步文件操作</td>
<td align="left">回调或 Future 模式</td>
</tr>
<tr>
<td align="left"><code>AsynchronousSocketChannel</code></td>
<td align="left">异步 TCP 通信</td>
<td align="left">非阻塞、高并发支持</td>
</tr>
</tbody></table>
<h4><span id="filechannel类">FileChannel类</span></h4><p>用于文件的读写、内存映射及零拷贝传输。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>读写操作</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>int read(ByteBuffer dst)</code></td>
<td align="left">从通道读取数据到 <code>ByteBuffer</code>，返回实际读取的字节数（可能为 <code>0</code>）。</td>
</tr>
<tr>
<td align="left"><code>int write(ByteBuffer src)</code></td>
<td align="left">将 <code>ByteBuffer</code> 中的数据写入通道，返回实际写入的字节数。</td>
</tr>
<tr>
<td align="left"><strong>定位与截断</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>long position()</code></td>
<td align="left">返回当前文件指针的位置。</td>
</tr>
<tr>
<td align="left"><code>FileChannel position(long newPosition)</code></td>
<td align="left">设置文件指针的位置（用于随机读写）。</td>
</tr>
<tr>
<td align="left"><code>FileChannel truncate(long size)</code></td>
<td align="left">截断文件到指定大小（丢弃超出部分）。</td>
</tr>
<tr>
<td align="left"><strong>内存映射与零拷贝</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>MappedByteBuffer map(MapMode mode, long position, long size)</code></td>
<td align="left">将文件映射到内存，返回 <code>MappedByteBuffer</code>。模式包括：<code>READ_ONLY</code>、<code>READ_WRITE</code>、<code>PRIVATE</code>。</td>
</tr>
<tr>
<td align="left"><code>long transferTo(long position, long count, WritableByteChannel target)</code></td>
<td align="left">将文件数据从 <code>position</code> 开始的 <code>count</code> 字节直接传输到目标通道（零拷贝优化）。</td>
</tr>
<tr>
<td align="left"><code>long transferFrom(ReadableByteChannel src, long position, long count)</code></td>
<td align="left">从源通道读取数据，直接写入文件的指定位置（零拷贝优化）。</td>
</tr>
<tr>
<td align="left"><strong>文件锁</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>FileLock lock()</code></td>
<td align="left">获取文件的独占锁（阻塞直到获取成功）。</td>
</tr>
<tr>
<td align="left"><code>FileLock tryLock()</code></td>
<td align="left">尝试非阻塞获取锁，失败返回 <code>null</code>。</td>
</tr>
</tbody></table>
<p><img src="/./../images/image-20250512100231746.png" alt="image-20250512100231746"></p>
<h4><span id="socketchannel类">SocketChannel类</span></h4><p>（TCP 客户端）</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean connect(SocketAddress remote)</code></td>
<td align="left">连接到服务端地址。在非阻塞模式下可能返回 <code>false</code>，需后续调用 <code>finishConnect()</code> 完成连接。</td>
</tr>
<tr>
<td align="left"><code>boolean finishConnect()</code></td>
<td align="left">完成非阻塞模式下的连接过程（需循环检查）。</td>
</tr>
<tr>
<td align="left"><code>boolean isConnected()</code></td>
<td align="left">检查是否已成功连接到服务端。</td>
</tr>
<tr>
<td align="left"><strong>非阻塞模式</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>SocketChannel configureBlocking(boolean block)</code></td>
<td align="left">设置阻塞模式（<code>true</code> 为阻塞，默认值）。</td>
</tr>
<tr>
<td align="left"><strong>注册到 Selector</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>SelectionKey register(Selector sel, int ops)</code></td>
<td align="left">将通道注册到 <code>Selector</code>，监听指定事件（如 <code>SelectionKey.OP</code></td>
</tr>
</tbody></table>
<p><img src="/./../images/image-20250512100841362.png" alt="image-20250512100841362"></p>
<h4><span id="serversocketchannel类">ServerSocketChannel类</span></h4><p>（TCP 服务端）</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ServerSocketChannel bind(SocketAddress local)</code></td>
<td align="left">绑定到指定端口（如 <code>new InetSocketAddress(8080)</code>）。</td>
</tr>
<tr>
<td align="left"><code>SocketChannel accept()</code></td>
<td align="left">接受客户端连接请求，返回对应的 <code>SocketChannel</code>（阻塞模式下会等待连接）。</td>
</tr>
<tr>
<td align="left"><strong>非阻塞模式</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>configureBlocking(boolean block)</code></td>
<td align="left">设置非阻塞模式后，<code>accept()</code> 可能立即返回 <code>null</code>。</td>
</tr>
</tbody></table>
<p><img src="/./../images/image-20250512100908934.png" alt="image-20250512100908934"></p>
<h4><span id="datagramchannel类">DatagramChannel类</span></h4><p>（UDP 通信）</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>DatagramChannel bind(SocketAddress local)</code></td>
<td align="left">绑定本地端口接收数据（如 <code>new InetSocketAddress(9090)</code>）。</td>
</tr>
<tr>
<td align="left"><code>int send(ByteBuffer src, SocketAddress target)</code></td>
<td align="left">发送数据包到目标地址。</td>
</tr>
<tr>
<td align="left"><code>SocketAddress receive(ByteBuffer dst)</code></td>
<td align="left">接收数据包到 <code>ByteBuffer</code>，返回发送方的地址。</td>
</tr>
</tbody></table>
<p><img src="/./../images/image-20250512100938931.png" alt="image-20250512100938931"></p>
<h3><span id="3selector">3.Selector</span></h3><p>用一个线程处理多个客户端连接，就会用到Selector，可以检测注册的多个通道中是否有事件发生，只有通道有读写事件发生时才会进行读写操作，不必为每个连接都创建线程，减少系统开销</p>
<p>Selector是一个抽象类</p>
<p><img src="/./../images/image-20250512101426081.png" alt="image-20250512101426081"></p>
<h4><span id="核心特点">核心特点：</span></h4><ol>
<li><strong>多路复用</strong>：单线程可管理多个 <code>Channel</code>，减少线程资源消耗。</li>
<li><strong>非阻塞模式</strong>：需将 <code>Channel</code> 设置为非阻塞模式（<code>configureBlocking(false)</code>）才能注册到 <code>Selector</code>。</li>
<li><strong>事件驱动</strong>：通过监听 <code>SelectionKey</code> 标识的事件（如 <code>OP_READ</code>、<code>OP_WRITE</code>）触发操作。</li>
</ol>
<h4><span id="常用方法"><strong>常用方法</strong></span></h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>static Selector open()</code></strong></td>
<td align="left">创建一个新的 <code>Selector</code> 实例。</td>
</tr>
<tr>
<td align="left"><strong><code>int select()</code></strong></td>
<td align="left">阻塞等待至少一个已注册的 <code>Channel</code> 就绪事件，返回就绪事件的数量。</td>
</tr>
<tr>
<td align="left"><strong><code>int select(long timeout)</code></strong></td>
<td align="left">阻塞最多 <code>timeout</code> 毫秒，超时返回 <code>0</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>int selectNow()</code></strong></td>
<td align="left">非阻塞检查就绪事件，立即返回当前就绪数量。</td>
</tr>
<tr>
<td align="left"><strong><code>Set&lt;SelectionKey&gt; selectedKeys()</code></strong></td>
<td align="left">返回已就绪的事件集合（需手动清理已处理的 <code>SelectionKey</code>）。</td>
</tr>
<tr>
<td align="left"><strong><code>Set&lt;SelectionKey&gt; keys()</code></strong></td>
<td align="left">返回所有注册到该 <code>Selector</code> 的 <code>SelectionKey</code> 集合（不可直接修改）。</td>
</tr>
<tr>
<td align="left"><strong><code>Selector wakeup()</code></strong></td>
<td align="left">唤醒因 <code>select()</code> 阻塞的线程。</td>
</tr>
<tr>
<td align="left"><strong><code>void close()</code></strong></td>
<td align="left">关闭 <code>Selector</code> 并释放资源。</td>
</tr>
</tbody></table>
<h3><span id="聊天案例">聊天案例</span></h3><p><img src="/./../images/image-20250512155357167.png" alt="image-20250512155357167"></p>
<h4><span id="服务端">服务端</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.nio.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="comment">// 存储当前群聊的所有在线用户</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;SocketChannel&gt; clients = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;SocketChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建服务器通道并绑定端口</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 2.绑定端口并设置为非阻塞</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3333</span>));</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动成功&quot;</span> + server.getLocalAddress());</span><br><span class="line">        <span class="comment">// 3.创建选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 4.注册服务器通道到选择器中</span></span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 5.等待客户端连接</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 6.获取选择器中所有注册的通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 7.遍历选择器中的所有通道</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">// 8.处理每个通道</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove(); <span class="comment">// 必须移除已处理的 key</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 9.处理新连接</span></span><br><span class="line">                    handleAccept(key, selector);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 10.处理数据读取</span></span><br><span class="line">                    handleRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理新连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleAccept</span><span class="params">(SelectionKey key, Selector selector)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel(); <span class="comment">// 获取服务器通道</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverChannel.accept(); <span class="comment">// 获取客户端通道</span></span><br><span class="line">            clients.add(socketChannel);</span><br><span class="line">            socketChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">// 设置为非阻塞</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ); <span class="comment">// 注册到选择器中</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端连接: &quot;</span> + socketChannel.getRemoteAddress());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理读写</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRead</span><span class="params">(SelectionKey key)</span>&#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bytesRead = clientChannel.read(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            closeClient(clientChannel);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">            closeClient(clientChannel);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.remaining()];</span><br><span class="line">            buffer.get(data);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data).trim();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端收到消息 [&quot;</span> + clientChannel.getRemoteAddress() + <span class="string">&quot;]: &quot;</span> + message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 广播给其他客户端</span></span><br><span class="line">            broadcastMessage(message, clientChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">broadcastMessage</span><span class="params">(String message, SocketChannel clientChannel)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (clients.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">       <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.wrap((message + <span class="string">&#x27;\n&#x27;</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap((message + <span class="string">&quot;\n&quot;</span>).getBytes());</span><br><span class="line">        <span class="keyword">for</span> (SocketChannel client : clients) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client != clientChannel &amp;&amp; client.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client.write(buffer);</span><br><span class="line">                    buffer.rewind(); <span class="comment">// 重置buffer供下次写入</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    closeClient(client);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeClient</span><span class="params">(SocketChannel clientChannel)</span> &#123;</span><br><span class="line">        clients.remove(clientChannel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端断开连接: &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line">            clientChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="客户端">客户端</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.nio.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3333</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;连接服务器...&quot;</span>);</span><br><span class="line">        <span class="comment">// 等待连接完成</span></span><br><span class="line">        <span class="keyword">while</span> (!client.finishConnect()) &#123;</span><br><span class="line">            <span class="comment">// 可以做一些其他处理或者等待</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开启线程读取服务端推送的消息</span></span><br><span class="line">        <span class="comment">// 启动读取线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 从缓冲区读取数据</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> client.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(<span class="string">&quot;[群消息] &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, bytesRead));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 循环发送消息</span></span><br><span class="line">        <span class="comment">// 控制台输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// 发送给服务器端</span></span><br><span class="line">            client.write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(msg)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="零拷贝">零拷贝</span></h3><h4><span id="什么是零拷贝">什么是零拷贝？</span></h4><blockquote>
<p>​	零拷贝（Zero-copy）技术指在计算机执行操作时，<strong>CPU 不需要先将数据从⼀个内存区域复制到另⼀个内存区域</strong>，从⽽可以减少上下⽂切换以及 CPU 的拷贝时间。它的作用是在数据从网络设备到⽤户程序空间传递的过程中，<strong>减少数据拷贝次数，减少系统调用，实现 CPU 的零参与，彻底消除 CPU 在这方面的负载</strong>。</p>
<p>　　实现零拷贝用到的最主要技术是 <strong>DMA 数据传输技术</strong>和<strong>内存区域映射技术</strong>。</p>
<p>　　零拷贝机制可以减少数据在内核缓冲区和⽤户进程缓冲区之间反复的 I&#x2F;O 拷贝操作。零拷贝机制可以减少用户进程地址空间和内核地址空间之间因为上下⽂切换⽽带来的 CPU 开销。在 Java 程序中，常⽤的零拷贝有 mmap（内存映射）和 sendFile。</p>
<p>源自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liconglong/p/15211413.html">https://www.cnblogs.com/liconglong/p/15211413.html</a></p>
</blockquote>
<h4><span id="传统-ix2fo-的数据拷贝流程"><strong>传统 I&#x2F;O 的数据拷贝流程</strong></span></h4><p><strong>4 次上下文切换 + 4 次数据拷贝（其中 2 次由 CPU 参与），效率较低。</strong></p>
<p>在传统 I&#x2F;O 操作中（例如从文件读取数据并发送到网络），数据需要经历多次拷贝和上下文切换：</p>
<ol>
<li><strong>磁盘 → 内核缓冲区</strong>：数据从磁盘读取到内核空间的缓冲区（通过 DMA 技术）。</li>
<li><strong>内核缓冲区 → 用户缓冲区</strong>：数据从内核空间拷贝到用户空间的应用程序缓冲区（需要 CPU 参与）。</li>
<li><strong>用户缓冲区 → Socket 缓冲区</strong>：应用程序将数据从用户缓冲区拷贝到内核空间的 Socket 缓冲区（再次 CPU 参与）。</li>
<li><strong>Socket 缓冲区 → 网卡</strong>：数据从 Socket 缓冲区发送到网络设备（通过 DMA）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file/test01.txt&quot;</span>);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">        randomAccessFile.read(bytes); <span class="comment">// 读取文件</span></span><br><span class="line">        <span class="comment">// 创建服务端 等待客户端连接发送文件</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">3333</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3333</span>));</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        inputStream.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="零拷贝的两种常见实现"><strong>零拷贝的两种常见实现</strong></span></h4><ol>
<li><strong><code>sendfile</code> 系统调用</strong>：<ul>
<li>数据直接从文件描述符传输到 Socket 描述符，无需用户态参与。</li>
<li>适用于文件到网络的传输（如 HTTP 文件下载）。</li>
</ul>
</li>
<li><strong>内存映射文件（<code>mmap</code>）</strong>：<ul>
<li>将文件映射到用户态虚拟内存，用户程序直接操作内存，减少拷贝次数。</li>
<li>适用于需要频繁修改文件的场景（如数据库）</li>
</ul>
</li>
</ol>
<h4><span id="mmap-和-sendfile-的区别"><strong>mmap</strong> <strong>和</strong> <strong>sendFile</strong> <strong>的区别</strong></span></h4><p>1.mmap 适合小数据量读写，sendFile 适合大文件传输。</p>
<p>2.mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。</p>
<p>3.sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。</p>
<h4><span id="传统-ix2fo-vs-nio-零拷贝的对比"><strong>传统 I&#x2F;O vs NIO 零拷贝的对比</strong></span></h4><table>
<thead>
<tr>
<th align="left"><strong>步骤</strong></th>
<th align="left"><strong>传统 I&#x2F;O</strong></th>
<th align="left"><strong>NIO + 零拷贝</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据拷贝次数</strong></td>
<td align="left">4 次（2 次用户态↔内核态）</td>
<td align="left">2 次（仅内核态内拷贝）</td>
</tr>
<tr>
<td align="left"><strong>CPU 参与次数</strong></td>
<td align="left">2 次（用户态↔内核态拷贝）</td>
<td align="left">0 次（DMA 完成）</td>
</tr>
<tr>
<td align="left"><strong>上下文切换次数</strong></td>
<td align="left">4 次（读&#x2F;写各 2 次）</td>
<td align="left">2 次（系统调用发起和完成）</td>
</tr>
<tr>
<td align="left"><strong>典型实现</strong></td>
<td align="left"><code>FileInputStream.read()</code> + <code>Socket.send()</code></td>
<td align="left"><code>FileChannel.transferTo()</code></td>
</tr>
</tbody></table>
<h4><span id="dma和内存映射">DMA和内存映射</span></h4><table>
<thead>
<tr>
<th align="left"><strong>技术</strong></th>
<th align="left"><strong>核心作用</strong></th>
<th align="left"><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DMA</strong></td>
<td align="left">外设与内存直接传输数据，减少 CPU 参与</td>
<td align="left">磁盘 I&#x2F;O、网络通信、GPU 渲染</td>
</tr>
<tr>
<td align="left"><strong>内存区域映射</strong></td>
<td align="left">将外设或文件映射到内存，实现零拷贝访问</td>
<td align="left">文件高效读写、硬件控制、进程间通信</td>
</tr>
</tbody></table>
<h4><span id="零拷贝性能分析">零拷贝性能分析</span></h4><p>（服务端向客户端发送大文件）</p>
<h5><span id="不使用零拷贝">不使用零拷贝：</span></h5><p>OldServer.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3333</span>));</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        selector.select(); <span class="comment">// 阻塞等待客户端连接</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                handle(selectionKey, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (t2 - t1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file/protoc-3.6.1-win32.zip&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">// 注册</span></span><br><span class="line">        client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">// 获取文件输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileInputStream.available() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            fileInputStream.read(bytes);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> client.write(ByteBuffer.wrap(bytes));</span><br><span class="line">            System.out.println(<span class="string">&quot;发送了：&quot;</span> + sum + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OldClient.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3333</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;连接服务器...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!client.finishConnect()) &#123;</span><br><span class="line">            <span class="comment">// 可以做一些其他处理或者等待</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接完成...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接完成...&quot;</span>);</span><br><span class="line">        <span class="comment">// 从服务器读取数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>  (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(bytes);</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> client.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (t2 - t1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="使用零拷贝">使用零拷贝：</span></h5><p>NewServer.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3333</span>));</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        selector.select();</span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                handle(selectionKey, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (t2 - t1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(SelectionKey key, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">        <span class="comment">// 1.获得客户端</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 2.注册</span></span><br><span class="line">        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">// 3.获得文件输出流</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;file/protoc-3.6.1-win32.zip&quot;</span>;</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename).getChannel();</span><br><span class="line">        <span class="comment">// 4.使用transferTo实现零拷贝传输</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> channel.transferTo(<span class="number">0</span>, channel.size(), client);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送了&quot;</span> + sum + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NewClient.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client = SocketChannel.open();</span><br><span class="line">            client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">3333</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;连接服务器...&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!client.finishConnect()) &#123;</span><br><span class="line">                <span class="comment">// 等待连接完成</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;正在连接中。。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    read = client.read(buffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;服务端已关闭连接&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到服务端的消息：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, read));</span><br><span class="line">                    buffer.clear(); <span class="comment">// 清空 buffer 以便下次读取</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 等待数据到达</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;连接已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性能比较：</p>
<p><img src="/../images/image-20250513143311587.png" alt="image-20250513143311587"></p>
<p><img src="/./../images/image-20250513143341454.png" alt="image-20250513143341454"></p>
<blockquote>
<p>很显然零拷贝性能要高很多</p>
</blockquote>
<h1><span id="reactor模式">Reactor模式</span></h1><h2><span id="什么是reactor模式">什么是Reactor模式？</span></h2><p>Reactor 模式是一种事件驱动模型，核心思想是 <strong>通过一个或多个线程监听 I&#x2F;O 事件（如连接、读写），并将事件分发给对应的处理器</strong>。常见的 Reactor 变体包括：</p>
<ul>
<li><strong>单 Reactor 单线程</strong>：所有操作（连接、I&#x2F;O）由一个线程完成，简单但性能受限。</li>
<li><strong>单 Reactor 多线程</strong>：主线程处理连接，I&#x2F;O 操作交给线程池，但主线程可能成为瓶颈。</li>
<li><strong>主从 Reactor 多线程</strong>：主 Reactor 处理连接，子 Reactor 处理 I&#x2F;O，Netty 默认采用此模式。</li>
</ul>
<p><img src="/./../images/image-20250513224534582.png" alt="image-20250513224534582"></p>
<h3><span id="理解">理解：</span></h3><p>reactor可以认为是一种设计模式，用于处理客户端的事件，主要是通过select和dispatch操作来监听事件发生和处理事件</p>
<h3><span id="主要逻辑">主要逻辑：</span></h3><blockquote>
<p>1.服务器注册到selector中，为其连接事件分配一个Handler（其实是一个Runnable对象， 名称可以定义为Acceptor）</p>
<p>2.Reactor监听事件发生，当事件发生时，会通过dispatch将时间分发给具体的处理器</p>
<p>3.dispatch通过SelectionKey（可以认为是selector实例对象中的事件id）的attachment来获取具体的Handler</p>
<p>4.执行具体的Handler逻辑</p>
</blockquote>
<h2><span id="单reactor单线程">单Reactor单线程</span></h2><h3><span id="键值存储服务器">键值存储服务器:</span></h3><p>SingleThreadReactorKVStore.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单线程 Reactor 模式的键值存储服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadReactorKVStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; store = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 内存键值存储</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化服务器通道和选择器，并监听指定端口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port 服务器监听的端口号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果初始化通道或选择器时发生I/O错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SingleThreadReactorKVStore</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 注册 Accept 事件到 Reactor</span></span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">new</span> <span class="title class_">Acceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务器，进入事件循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reactor thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select(); <span class="comment">// 阻塞等待事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                    dispatch(key); <span class="comment">// 根据事件类型分发事件到具体的处理器</span></span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverChannel.close();</span><br><span class="line">                selector.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分发事件到对应的处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 事件的 SelectionKey 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取与键关联的附件，这里附件是一个Runnable对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">handler</span> <span class="operator">=</span> (Runnable) key.attachment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查获取到的handler是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">            handler.run(); <span class="comment">// 执行 Handler（Acceptor 或 IOHandler）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 连接事件 的 Handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Acceptor thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端新连接 : &quot;</span> + clientChannel.getRemoteAddress());</span><br><span class="line">                <span class="keyword">if</span> (clientChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">IOHandler</span>(clientChannel); <span class="comment">// 处理新连接的 I/O</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 I/O 的 Handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">IOHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造函数，初始化 SocketChannel 并注册读事件到选择器</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel 接收到的客户端通道</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IOException 如果配置通道时发生I/O错误</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IOHandler</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel = channel;</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 注册读事件到 Reactor</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IOHandler thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 检查通道是否已经关闭，如果关闭则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (!channel.isOpen()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 清空缓冲区以准备读取新的数据</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">                <span class="comment">// 读取数据到缓冲区</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                <span class="comment">// 如果没有更多数据可读，关闭通道并返回</span></span><br><span class="line">                <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析请求并执行业务逻辑（单线程处理）</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.limit()).trim();</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> processCommand(request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回响应</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">respBuffer</span> <span class="operator">=</span> ByteBuffer.wrap((response + <span class="string">&quot;\n&quot;</span>).getBytes());</span><br><span class="line">                channel.write(respBuffer);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// 如果发生IO异常，尝试关闭通道</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    <span class="comment">// 如果关闭通道时发生异常，打印异常信息</span></span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务逻辑处理（单线程执行）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> request 客户端请求的字符串</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 处理结果的字符串</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String <span class="title function_">processCommand</span><span class="params">(String request)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Processing command: &quot;</span> + request);</span><br><span class="line">            String[] parts = request.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (parts.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="string">&quot;ERROR: Invalid command&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> parts[<span class="number">0</span>].toUpperCase();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> parts[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;SET&quot;</span>:</span><br><span class="line">                    <span class="keyword">if</span> (parts.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="string">&quot;ERROR: Missing value&quot;</span>;</span><br><span class="line">                    store.put(key, parts[<span class="number">2</span>]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> store.getOrDefault(key, <span class="string">&quot;(nil)&quot;</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;ERROR: Unknown command&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SingleThreadReactorKVStore</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleThreadReactorKVStore</span>(<span class="number">3333</span>);</span><br><span class="line">        server.start(); <span class="comment">// 单一线程运行所有逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Client.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">isConnected</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">3333</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待连接完成</span></span><br><span class="line">        <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接完成...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接到服务器&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听服务器消息（包括连接关闭）</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">readThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (isConnected.get()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 服务器关闭连接</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;[服务器已关闭连接]&quot;</span>);</span><br><span class="line">                        isConnected.set(<span class="literal">false</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(<span class="string">&quot;[服务器消息] &quot;</span> +</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, bytesRead));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected.get()) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;连接异常: &quot;</span> + e.getMessage());</span><br><span class="line">                    isConnected.set(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                closeChannel(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        readThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息循环</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isConnected.get()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(line)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!isConnected.get()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接已断开，无法发送消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(line.getBytes());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;已发送: &quot;</span> + line);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;发送失败: &quot;</span> + e.getMessage());</span><br><span class="line">                    isConnected.set(<span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        closeChannel(socketChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;连接已关闭&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/./../images/image-20250513220737289.png" alt="image-20250513220737289"></p>
<h2><span id="单-reactor-多线程">单 Reactor 多线程</span></h2><h3><span id="简单http-服务器">简单HTTP 服务器：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单 Reactor 多线程的 HTTP 服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleReactorMultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">businessPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); <span class="comment">// 业务线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SingleReactorMultiThreadServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">new</span> <span class="title class_">Acceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reactor thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                    dispatch(key);</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">handler</span> <span class="operator">=</span> (Runnable) key.attachment();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">            handler.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理新连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">IOHandler</span>(client); <span class="comment">// 注册读事件</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 I/O 和业务逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">IOHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IOHandler</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel = channel;</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!channel.isOpen()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reactor 线程处理读事件（非阻塞）</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">                <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析请求（示例：HTTP GET）</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.limit());</span><br><span class="line">                <span class="keyword">if</span> (request.startsWith(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 提交耗时任务到线程池</span></span><br><span class="line">                    businessPool.submit(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            processRequest(request);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(String request)</span> <span class="keyword">throws</span> ClosedChannelException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Business thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length: 12\r\n\r\nHello World!&quot;</span>;</span><br><span class="line">            <span class="comment">// 传递 channel 到 WriteHandler</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_WRITE, <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(channel, response));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 写操作 的  Handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;  <span class="comment">// 新增成员变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String response;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WriteHandler</span><span class="params">(SocketChannel channel, String response)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel = channel;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(response.getBytes());</span><br><span class="line">                channel.write(buffer);</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SingleReactorMultiThreadServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleReactorMultiThreadServer</span>(<span class="number">3333</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../images/image-20250513215117104.png" alt="image-20250513215117104"></p>
<p><img src="/./../images/image-20250513215203737.png" alt="image-20250513215203737"></p>
<h2><span id="主从-reactor-多线程案例">主从 Reactor 多线程案例</span></h2><h3><span id="简易http服务器">简易Http服务器：</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主从Reactor模式下的简易Http服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MasterSlaveReactorServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主 Reactor 线程组（单线程）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reactor bossReactor;</span><br><span class="line">    <span class="comment">// 从 Reactor 线程组（多线程）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reactor[] workerReactors;</span><br><span class="line">    <span class="comment">// 轮询计数器，用于分配连接给 Worker</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">workerIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 业务线程池（处理耗时任务）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">businessPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MasterSlaveReactorServer</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> workerCount)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 初始化主 Reactor</span></span><br><span class="line">        bossReactor = <span class="keyword">new</span> <span class="title class_">Reactor</span>(<span class="string">&quot;Boss&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化从 Reactor 组</span></span><br><span class="line">        workerReactors = <span class="keyword">new</span> <span class="title class_">Reactor</span>[workerCount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            workerReactors[i] = <span class="keyword">new</span> <span class="title class_">Reactor</span>(<span class="string">&quot;Worker-&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主 Reactor 绑定 ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">        serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        bossReactor.register(serverChannel, SelectionKey.OP_ACCEPT, <span class="keyword">new</span> <span class="title class_">Acceptor</span>(serverChannel));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动主从 Reactor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        bossReactor.start();</span><br><span class="line">        <span class="keyword">for</span> (Reactor worker : workerReactors) &#123;</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主 Reactor 的 Acceptor，处理新连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannel serverChannel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Acceptor</span><span class="params">(ServerSocketChannel serverChannel)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.serverChannel = serverChannel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主Reactor-thread : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                <span class="keyword">if</span> (clientChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 轮询选择一个 Worker Reactor</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> workerIndex.getAndIncrement() % workerReactors.length;</span><br><span class="line">                    <span class="type">Reactor</span> <span class="variable">worker</span> <span class="operator">=</span> workerReactors[index];</span><br><span class="line">                    <span class="comment">// 将新连接注册到 Worker Reactor</span></span><br><span class="line">                    worker.registerChannel(clientChannel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reactor 线程（主和从共用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Reactor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Reactor</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册 Channel 到当前 Reactor</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">            <span class="comment">// 异步提交注册任务，避免线程阻塞</span></span><br><span class="line">            addTask(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    key.attach(<span class="keyword">new</span> <span class="title class_">IOHandler</span>(channel, key));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup(); <span class="comment">// 唤醒 select() 阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加异步任务（线程安全）</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            taskQueue.offer(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;从Reactor : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                    selector.select(<span class="number">1000</span>); <span class="comment">// 超时 1 秒，避免无法唤醒</span></span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                    processPendingTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理已就绪的 SelectionKey</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeys</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isValid()) &#123;</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">handler</span> <span class="operator">=</span> (Runnable) key.attachment();</span><br><span class="line">                    <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                        handler.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理异步任务队列</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processPendingTasks</span><span class="params">()</span> &#123;</span><br><span class="line">            Runnable task;</span><br><span class="line">            <span class="keyword">while</span> ((task = taskQueue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServerSocketChannel serverChannel, <span class="type">int</span> opAccept, Acceptor acceptor)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                serverChannel.register(selector, opAccept, acceptor);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// I/O 处理器（从 Reactor 线程执行）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">IOHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SelectionKey key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IOHandler</span><span class="params">(SocketChannel channel, SelectionKey key)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel = channel;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IOHandler-thread : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!channel.isOpen()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理读事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 提交业务逻辑到线程池</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.limit());</span><br><span class="line">                    businessPool.submit(() -&gt; processRequest(request));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理写事件（示例省略，实际需注册 OP_WRITE）</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务处理（在线程池执行）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length: 13\r\n\r\nHello Reactor!&quot;</span>;</span><br><span class="line">            <span class="comment">// 写回响应（需切换回 Reactor 线程）</span></span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">            key.attach(<span class="keyword">new</span> <span class="title class_">WriteHandler</span>(channel, response));</span><br><span class="line">            key.selector().wakeup(); <span class="comment">// 唤醒 Selector</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写处理器（由 Reactor 线程执行）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String response;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改构造函数，传入 channel</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WriteHandler</span><span class="params">(SocketChannel channel, String response)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.channel = channel;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;WriteHandler-thread : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(response.getBytes());</span><br><span class="line">                channel.write(buffer);</span><br><span class="line">                channel.close(); <span class="comment">// 短连接示例，关闭连接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 启动服务器：1 个主 Reactor，4 个从 Reactor</span></span><br><span class="line">        <span class="type">MasterSlaveReactorServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MasterSlaveReactorServer</span>(<span class="number">3333</span>, <span class="number">4</span>);</span><br><span class="line">        server.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器已启动，主从 Reactor 模式运行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../images/image-20250513231248851.png" alt="image-20250513231248851"></p>
<p><img src="/./../images/image-20250513231314582.png" alt="image-20250513231314582"></p>
<h1><span id="netty">Netty</span></h1><h2><span id="介绍">介绍</span></h2><ul>
<li>Netty 是一个 <strong>NIO 客户端服务器框架</strong>，可以快速轻松地开发网络应用程序（例如协议服务器和客户端）。它极大地简化了 TCP 和 UDP 套接字服务器等网络编程。</li>
<li>它基于 Java NIO（Non-blocking I&#x2F;O）技术，简化了网络编程的复杂性，广泛应用于实时通信、游戏服务器、分布式系统等领域（如 Dubbo、RocketMQ 等框架的底层通信）。</li>
</ul>
<p>官方文档：<a target="_blank" rel="noopener" href="https://netty.io/4.2/api/index.html">https://netty.io/4.2/api/index.html</a></p>
<p><img src="/./../images/1708060-20211110224700852-1182764791.png" alt="1708060-20211110224700852-1182764791"></p>
<p>图源：<a target="_blank" rel="noopener" href="https://img2020.cnblogs.com/blog/1708060/202111/1708060-20211110224700852-1182764791.png">https://img2020.cnblogs.com/blog/1708060/202111/1708060-20211110224700852-1182764791.png</a></p>
<p>Netty启动流程：</p>
<p><img src="/./../images/be1c82f1634c1c3af59ebb114297733f.png" alt="img"></p>
<p>图源：<a target="_blank" rel="noopener" href="https://cloud.tencent.cn/developer/article/2146079">https://cloud.tencent.cn/developer/article/2146079</a></p>
<h2><span id="线程模式">线程模式</span></h2><p>Netty 基于 Reactor 模式设计，主要有三种线程模型：</p>
<ul>
<li><strong>单线程模型</strong>：所有 IO 操作由一个线程处理</li>
<li><strong>多线程模型</strong>：Acceptor 和 IO 处理器分离为不同线程组</li>
<li><strong>主从多线程模型</strong>：Acceptor 也使用线程池处理</li>
</ul>
<h2><span id="核心组件">核心组件</span></h2><h3><span id="serverbootstrap服务器启动类"><strong>ServerBootstrap（服务器启动类）</strong></span></h3><h4><span id="核心作用"><strong>核心作用</strong></span></h4><ul>
<li>用于配置和启动 Netty 服务器。</li>
<li>管理两个<code>EventLoopGroup</code>：BossGroup（接受连接）和 WorkerGroup（处理 IO）。</li>
</ul>
<h4><span id="关键方法"><strong>关键方法</strong></span></h4><ul>
<li><code>group(EventLoopGroup bossGroup, EventLoopGroup workerGroup)</code>：设置主从线程组。</li>
<li><code>channel(Class&lt;? extends ServerChannel&gt; channelClass)</code>：设置服务器通道类型（如<code>NioServerSocketChannel</code>）。</li>
<li><code>childHandler(ChannelHandler childHandler)</code>：设置子通道处理器（客户端连接的 Pipeline）。</li>
<li><code>option(ChannelOption option, T value)</code>：设置服务器通道选项（如<code>SO_BACKLOG</code>）。</li>
<li><code>childOption(ChannelOption option, T value)</code>：设置子通道选项（如<code>SO_KEEPALIVE</code>）。</li>
<li><code>bind(int port)</code>：绑定端口并启动服务器。</li>
</ul>
<h3><span id="bootstrap客户端启动类"><strong>Bootstrap（客户端启动类）</strong></span></h3><h4><span id="核心作用"><strong>核心作用</strong></span></h4><ul>
<li>用于配置和启动 Netty 客户端。</li>
<li>只需要一个<code>EventLoopGroup</code>处理所有连接和 IO 操作。</li>
</ul>
<h4><span id="关键方法"><strong>关键方法</strong></span></h4><ul>
<li><code>group(EventLoopGroup group)</code>：设置线程组。</li>
<li><code>channel(Class&lt;? extends Channel&gt; channelClass)</code>：设置客户端通道类型（如<code>NioSocketChannel</code>）。</li>
<li><code>handler(ChannelHandler handler)</code>：设置通道处理器（客户端 Pipeline）。</li>
<li><code>option(ChannelOption option, T value)</code>：设置通道选项（如<code>SO_KEEPALIVE</code>）。</li>
<li><code>connect(String host, int port)</code>：连接到远程服务器。</li>
</ul>
<h3><span id="eventloopgroup-与-eventloop"><strong>EventLoopGroup 与 EventLoop</strong></span></h3><ul>
<li><strong>EventLoopGroup</strong>：线程池，管理多个<code>EventLoop</code>。</li>
<li><strong>EventLoop</strong>：单线程执行器，负责处理 IO 事件（连接、读写）和任务队列。</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li><strong>NioEventLoopGroup</strong>：基于 Java NIO，跨平台。</li>
<li><strong>EpollEventLoopGroup</strong>：基于 Linux epoll，性能更高。</li>
</ul>
<h3><span id="channel"><strong>Channel</strong></span></h3><ul>
<li><code>NioSocketChannel</code>：客户端 TCP 连接。</li>
<li><code>NioServerSocketChannel</code>：服务器 TCP 监听。</li>
<li><code>NioDatagramChannel</code>：UDP 连接。</li>
</ul>
<h3><span id="channelpipeline"><strong>ChannelPipeline</strong></span></h3><ul>
<li><strong>入站（Inbound）</strong>：数据从网络到应用（如<code>channelRead()</code>）。</li>
<li><strong>出站（Outbound）</strong>：数据从应用到网络（如<code>write()</code>）。</li>
</ul>
<h3><span id="channelhandler"><strong>ChannelHandler</strong></span></h3><ul>
<li><strong>ChannelInboundHandler</strong>：处理入站数据。</li>
<li><strong>ChannelOutboundHandler</strong>：处理出站数据。</li>
</ul>
<p><strong>关键接口&#x2F;抽象类：</strong></p>
<ul>
<li><strong>ChannelInboundHandlerAdapter</strong>：入站处理器基类。</li>
<li><strong>ChannelOutboundHandlerAdapter</strong>：出站处理器基类。</li>
<li><strong>SimpleChannelInboundHandler</strong>：自动释放资源的入站处理器。</li>
</ul>
<h1><span id="案例分析群聊系统">案例分析（群聊系统）：</span></h1><h2><span id="服务器">服务器：</span></h2><h4><span id="chatserverclass">ChatServer.class</span></h4><p>服务器启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.netty.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1.创建主从线程组</span></span><br><span class="line">        <span class="comment">// 1.1 处理客户端连接</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// 1.2 处理事件</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workGroups</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.创建服务器</span></span><br><span class="line">            <span class="comment">// 创建并配置Netty服务器</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">// 设置服务器的BossGroup和WorkGroup</span></span><br><span class="line">            server.group(bossGroup, workGroups);</span><br><span class="line">            <span class="comment">// 指定服务器的通道类型</span></span><br><span class="line">            server.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">// 1. 主通道处理器（用于ServerSocketChannel，处理连接建立事件）</span></span><br><span class="line">            server.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioServerSocketChannel ch)</span> &#123;</span><br><span class="line">                    <span class="comment">// 配置主通道的处理器链（如日志记录、连接限制等）</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 2. 子通道处理器（用于SocketChannel，处理读写事件）</span></span><br><span class="line">            server.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">// 配置SocketChannel的管道</span></span><br><span class="line">                    socketChannel.pipeline().addLast(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">StringDecoder</span>(), <span class="comment">// 字符串解码器</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">StringEncoder</span>(), <span class="comment">// 字符串编码器</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">ChatServerHandler</span>(), <span class="comment">// 自定义处理器</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">ChatConnectionServerHandler</span>() <span class="comment">// 监听客户端状态</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 设置服务器的配置项</span></span><br><span class="line">            server.option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.绑定端口并启动服务</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">serverChannel</span> <span class="operator">=</span> server.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.等待服务器关闭</span></span><br><span class="line">            serverChannel.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workGroups.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChatServer</span> <span class="variable">chatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatServer</span>(<span class="number">3333</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chatServer.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="chatserverhandlerclass">ChatServerHandler.class</span></h4><p>处理客户端发来的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.netty.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器接收的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channelHandlerContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span>&#123;</span><br><span class="line">        <span class="type">SocketAddress</span> <span class="variable">socketAddress</span> <span class="operator">=</span> channelHandlerContext.channel().remoteAddress();</span><br><span class="line">        <span class="keyword">for</span> (Channel channel : ChatConnectionServerHandler.onlineUsers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!channel.remoteAddress().equals(socketAddress)) &#123;</span><br><span class="line">                channel.writeAndFlush(socketAddress + <span class="string">&quot;说: &quot;</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="chatconnectionserverhandlerclass">ChatConnectionServerHandler.class</span></h4><p>处理客户端连接和断开连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.netty.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatConnectionServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;Channel&gt; onlineUsers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Channel&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听信道的活跃状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">        onlineUsers.add(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  监听信道断开连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;断开连接&quot;</span>);</span><br><span class="line">        onlineUsers.remove(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="客户端">客户端：</span></h2><h4><span id="chatclientclass">ChatClient.class</span></h4><p>客户端启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.netty.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatClient</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">groups</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            client.group(groups);</span><br><span class="line">            client.channel(NioSocketChannel.class);</span><br><span class="line">            client.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    socketChannel.pipeline().addLast(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">StringDecoder</span>(),</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">StringEncoder</span>(),</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">ChatClientHandler</span>()</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 启动客户端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">clientChannel</span> <span class="operator">=</span> client.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  读取控制台输入 发送给服务器</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(msg)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                clientChannel.channel().writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待关闭</span></span><br><span class="line">            clientChannel.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            groups.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChatClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatClient</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">3333</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="chatclienthandlerclass">ChatClientHandler.class</span></h4><p>处理服务器发来的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcast.netty.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="运行结果">运行结果：</span></h2><p><img src="/./../images/image-20250516235353164.png" alt="image-20250516235353164"></p>
<h1><span id="netty源码剖析">Netty源码剖析</span></h1><h2><span id="eventloopgroup-和eventloop">EventLoopGroup 和EventLoop</span></h2><p>从EventLoopGroup接口的继承关系图可以从看出来这个接口继承了ExecutorService接口，说明是一个线程池</p>
<p><img src="/./../images/image-20250517104227454.png" alt="image-20250517104227454"></p>
<h3><span id><img src="/./../images/image-20250517104049002.png" alt="image-20250517104049002"></span></h3><p><img src="/./../images/image-20250517105748200.png" alt="image-20250517105748200"></p>
<h2><span id="nioeventloop">NioEventLoop</span></h2><ul>
<li><p>处理 I&#x2F;O 多路复用，监听 Channel 上的事件</p>
</li>
<li><p><code>NioEventLoop</code> 是 Netty 基于 Java NIO 机制构建的事件循环实现</p>
</li>
<li><p>NioEvent通过组合方式管理线程和任务。</p>
</li>
<li><p><code>NioEventLoop</code> → <code>SingleThreadEventLoop</code> → <code>SingleThreadEventExecutor</code> → <code>AbstractScheduledEventExecutor</code>。</p>
</li>
<li><p>Netty 采用 <strong>单线程模型</strong> 处理 Channel：</p>
<ul>
<li>每个 <code>EventLoop</code> 绑定一个 <strong>专属线程</strong>（<code>Thread</code>）。</li>
<li>该线程负责处理该 <code>EventLoop</code> 管理的 <strong>所有 Channel 的 IO 操作</strong>（如读、写、连接）。</li>
<li>所有 Channel 操作必须在其关联的 <code>EventLoop</code> 线程中执行，否则会导致线程安全问题。</li>
</ul>
</li>
</ul>
<p><img src="/./../images/image-20250517112950788.png" alt="image-20250517112950788"></p>
<h4><span id="重要字段">重要字段</span></h4><table>
<thead>
<tr>
<th>属性分类</th>
<th>关键属性</th>
<th>作用与优化点</th>
</tr>
</thead>
<tbody><tr>
<td>Selector 优化</td>
<td><code>selectedKeys</code></td>
<td>使用数组替代 <code>HashSet</code>，提升选择键处理性能</td>
</tr>
<tr>
<td>任务调度</td>
<td><code>taskQueue</code>、<code>scheduledTaskQueue</code></td>
<td>分离普通任务和定时任务，支持异步执行</td>
</tr>
<tr>
<td>线程控制</td>
<td><code>threadId</code>、<code>wakenUp</code></td>
<td>确保任务在正确线程执行，优化 <code>Selector.wakeup()</code> 调用</td>
</tr>
<tr>
<td>时间管理</td>
<td><code>ioRatio</code>、<code>lastExecutionTime</code></td>
<td>平衡 I&#x2F;O 操作和任务执行时间，避免任务饥饿</td>
</tr>
<tr>
<td>状态管理</td>
<td><code>state</code>、<code>needsToSelectAgain</code></td>
<td>控制事件循环状态，处理取消的 SelectionKey</td>
</tr>
</tbody></table>
<h5><span id="1selector相关字段">1.Selector相关字段</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java NIO Selector</span></span><br><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后的 Selector（通过反射替换为数组实现）</span></span><br><span class="line"><span class="keyword">private</span> SelectedSelectionKeySet selectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 Selector（未优化版本）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Selector unwrappedSelector;</span><br></pre></td></tr></table></figure>

<h5><span id="2任务队列相关字段">2.任务队列相关字段</span></h5><ul>
<li><code>taskQueue</code>：存储通过 <code>execute()</code> 提交的普通任务。</li>
<li><code>scheduledTaskQueue</code>：存储通过 <code>schedule()</code> 提交的定时任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通任务队列（无界队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时任务队列（基于优先级堆）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<ul>
<li><code>taskQueue</code> 默认使用 <code>MpscUnboundedArrayQueue</code>（多生产者单消费者队列）。</li>
<li><code>scheduledTaskQueue</code> 使用二叉堆实现，按执行时间排序。</li>
</ul>
<h5><span id="3父级eventloopgroup">3.父级EventLoopGroup</span></h5><p>表示当前EventLoop属于哪个EventLoopGroup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父级 EventLoopGroup</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NioEventLoopGroup parent;</span><br></pre></td></tr></table></figure>

<h5><span id="4线程相关">4.线程相关</span></h5><ul>
<li>确保任务在正确的线程中执行（通过 <code>inEventLoop()</code> 检查）。</li>
<li>控制 <code>Selector</code> 的唤醒机制（避免不必要的 <code>wakeup()</code> 调用）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 ID（用于检查是否在 EventLoop 线程中执行）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> threadId;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程唤醒标志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">wakenUp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程状态（-1: 未启动, 1: 已启动, 2: 关闭中）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> ST_NOT_STARTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大待处理任务数（默认 Integer.MAX_VALUE）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxPendingTasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝策略（当任务队列满时的处理方式）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler;</span><br></pre></td></tr></table></figure>

<h5><span id="5事件相关">5.事件相关</span></h5><ul>
<li><code>selectStrategy</code>：决定何时调用 <code>select()</code>、<code>selectNow()</code> 或跳过选择。</li>
<li><code>needsToSelectAgain</code>：标记是否需要重新执行 <code>select()</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择策略（控制 select() 行为）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStrategy selectStrategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待处理的取消键数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> cancelledKeys;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否需要重新选择</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> needsToSelectAgain;</span><br></pre></td></tr></table></figure>

<h5><span id="6-时间与执行控制属性"><strong>6. 时间与执行控制属性</strong></span></h5><ul>
<li><code>ioRatio</code>：控制 I&#x2F;O 操作与任务执行的时间分配。</li>
<li><code>lastExecutionTime</code>：用于计算任务执行超时和延迟调度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I/O 操作与任务执行的时间比例（默认 50%）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> ioRatio;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次执行任务的时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> lastExecutionTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行超时控制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SCHEDULE_PURGE_INTERVAL</span> <span class="operator">=</span> TimeUnit.SECONDS.toNanos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="线程管理">线程管理</span></h4><p><strong>每个 NioEventLoop 绑定一个独立线程</strong>：</p>
<ul>
<li>处理注册到<code>Selector</code>上的<strong>IO 事件</strong>（连接、读写等）。</li>
<li>执行用户提交的<strong>普通任务</strong>（通过<code>execute(task)</code>）和<strong>定时任务</strong>（通过<code>schedule(task, delay, unit)</code>）。</li>
<li>调度后续的任务执行（如定时任务）。</li>
</ul>
<p><code>NioEventLoop</code>内部没有线程池，它是一个<strong>单线程的事件循环</strong>，所有操作都在同一个线程中完成。</p>
<ul>
<li><code>NioEventLoop</code>会将耗时任务通过<code>NioEventLoopGroup</code>提交到外部的线程池中</li>
</ul>
<h4><span id="重要方法">重要方法</span></h4><h5><span id="run方法">run方法：</span></h5><p><img src="/./../images/image-20250517155039884.png" alt="image-20250517155039884"></p>
<p><strong>NioEventLoop</strong>通过内部线程执行 <code>run()</code> 方法，通过 <code>execute(Runnable)</code> 提交任务</p>
<ul>
<li><p>无限循环处理 I&#x2F;O 事件和任务队列。</p>
</li>
<li><p>通过 <code>processSelectedKeys()</code> 处理网络 I&#x2F;O。</p>
</li>
<li><p>通过 <code>runAllTasks()</code> 执行提交的 <code>Runnable</code> 任务。</p>
</li>
<li><p><code>calculateStrategy</code> 是 Netty 中用于决定 EventLoop 选择策略的核心方法，它平衡了 I&#x2F;O 事件处理与任务执行的优先级。该方法由 <code>SelectStrategy</code> 接口定义，默认实现为 <code>DefaultSelectStrategy</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO事件循环的主处理方法，负责轮询IO事件和执行任务</span></span><br><span class="line"><span class="comment"> * 这个方法实现了一个无限循环，不断地选择就绪的通道并处理IO事件，同时兼顾任务执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录select操作的连续唤醒次数，用于检测异常唤醒情况</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">selectCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主事件循环，持续运行直到线程关闭</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算选择策略：-3/-1表示需要阻塞select，-2表示退出循环，其他正数表示就绪通道数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">strategy</span> <span class="operator">=</span> selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="comment">// 处理需要阻塞等待IO事件的情况</span></span><br><span class="line">                <span class="keyword">case</span> -<span class="number">3</span>:</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">                    <span class="comment">// 获取下一个定时任务的截止时间</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">curDeadlineNanos</span> <span class="operator">=</span> nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        curDeadlineNanos = Long.MAX_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果没有待处理任务，进行阻塞select操作</span></span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                            strategy = select(curDeadlineNanos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 重置唤醒时间，允许其他线程唤醒selector</span></span><br><span class="line">                        nextWakeupNanos.lazySet(-<span class="number">1L</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// 退出事件循环的策略</span></span><br><span class="line">                <span class="keyword">case</span> -<span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">break</span> outerLoop;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加select计数并重置状态</span></span><br><span class="line">            ++selectCnt;</span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据IO比例配置处理IO事件和任务执行的时间分配</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            <span class="type">boolean</span> ranTasks;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理就绪的IO事件</span></span><br><span class="line">            <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                processSelectedKeys();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据IO比例执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                ranTasks = runAllTasks();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理IO事件</span></span><br><span class="line">                    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 计算IO操作耗时，并按比例执行任务</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    ranTasks = runAllTasks(ioTime * (<span class="type">long</span>)(<span class="number">100</span> - ioRatio) / (<span class="type">long</span>)ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有执行任务且select操作没有返回就绪通道，检查是否需要重置select计数</span></span><br><span class="line">            <span class="keyword">if</span> (!ranTasks &amp;&amp; strategy &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unexpectedSelectorWakeup(selectCnt)) &#123;</span><br><span class="line">                    selectCnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录select操作连续过早返回的情况，可能是JDK选择器实现的问题</span></span><br><span class="line">            <span class="keyword">if</span> (selectCnt &gt; <span class="number">3</span> &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;</span>, selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重置计数</span></span><br><span class="line">            selectCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 发生IO异常时重建选择器</span></span><br><span class="line">            rebuildSelector0();</span><br><span class="line">            selectCnt = <span class="number">0</span>;</span><br><span class="line">            handleLoopException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="comment">// 处理已取消键的异常</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;CancelledKeyException raised by a Selector &#123;&#125; - JDK bug?&quot;</span>, selector, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            <span class="comment">// 致命错误直接抛出</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 处理其他异常</span></span><br><span class="line">            handleLoopException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否正在关闭，如果是则关闭所有通道并确认关闭</span></span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6><span id="selectcurdeadlinenanos">**<code>select(curDeadlineNanos)</code>**：</span></h6><ul>
<li><code>deadlineNanos</code>:下一个定时任务的截止时间</li>
<li><code>Long.MAX_VALUE</code> 表示无定时任务，可永久阻塞</li>
<li><code>deadlineNanos + 995000L</code>：增加 <code>995000 纳秒</code>（约 1 毫秒）以<strong>避免浮点数精度误差</strong>。</li>
<li><code>deadlineToDelayNanos()</code>：计算当前时间到 <code>deadlineNanos</code> 的剩余时间（纳秒）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> deadlineNanos)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 情况1：无截止时间（永久阻塞）</span></span><br><span class="line">    <span class="keyword">if</span> (deadlineNanos == Long.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.selector.select(); <span class="comment">// 永久阻塞，直到有 I/O 事件就绪</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况2：有截止时间，计算超时时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> deadlineToDelayNanos(deadlineNanos + <span class="number">995000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据超时时间决定执行方式</span></span><br><span class="line">        <span class="keyword">return</span> timeoutMillis &lt;= <span class="number">0L</span> </span><br><span class="line">            ? <span class="built_in">this</span>.selector.selectNow()    <span class="comment">// 无超时（立即返回）</span></span><br><span class="line">            : <span class="built_in">this</span>.selector.select(timeoutMillis); <span class="comment">// 带超时的阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6><span id="processselectedkeys">**<code>processSelectedKeys</code>**：</span></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.selectedKeys != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用优化的数组实现（默认策略）</span></span><br><span class="line">        <span class="built_in">this</span>.processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 回退到 JDK 原生的 HashSet 实现</span></span><br><span class="line">        <span class="built_in">this</span>.processSelectedKeysPlain(<span class="built_in">this</span>.selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeysOptimized</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历优化后的数组（替代原生 HashSet&lt;SelectionKey&gt;）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> <span class="built_in">this</span>.selectedKeys.keys[i];</span><br><span class="line">        <span class="built_in">this</span>.selectedKeys.keys[i] = <span class="literal">null</span>; <span class="comment">// 清空引用，帮助 GC</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> k.attachment();</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            <span class="comment">// 处理 Channel 相关事件</span></span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理特殊任务（如 NioTask）</span></span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否需要重新选择（如发生 key 取消）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.needsToSelectAgain) &#123;</span><br><span class="line">            <span class="built_in">this</span>.selectedKeys.reset(i + <span class="number">1</span>); <span class="comment">// 重置数组游标</span></span><br><span class="line">            <span class="built_in">this</span>.selectAgain(); <span class="comment">// 重新执行 select()</span></span><br><span class="line">            i = -<span class="number">1</span>; <span class="comment">// 重新从数组头部开始遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeysPlain</span><span class="params">(Set&lt;SelectionKey&gt; selectedKeys)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!selectedKeys.isEmpty()) &#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> i.next();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> k.attachment();</span><br><span class="line">            i.remove(); <span class="comment">// 处理后立即从集合中移除，避免重复处理</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                <span class="comment">// 处理 Channel 相关事件</span></span><br><span class="line">                processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理特殊任务（如 NioTask）</span></span><br><span class="line">                NioTask&lt;SelectableChannel&gt; task = (NioTask) a;</span><br><span class="line">                processSelectedKey(k, task);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查是否需要重新选择</span></span><br><span class="line">            <span class="keyword">if</span> (!i.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 遍历完成，退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.needsToSelectAgain) &#123;</span><br><span class="line">                selectAgain(); <span class="comment">// 重新执行 select()</span></span><br><span class="line">                selectedKeys = <span class="built_in">this</span>.selector.selectedKeys(); <span class="comment">// 获取新的就绪 keys</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 没有新的就绪事件，退出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                i = selectedKeys.iterator(); <span class="comment">// 重置迭代器</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6><span id="runalltaskslong-timeoutnanos">**<code>runAllTasks(long timeoutNanos)</code>**：</span></h6><p>Netty 使用**优先级队列（PriorityQueue）**管理定时任务，队列中的任务按执行时间排序。当调用 <code>runAllTasks()</code> 时，会先将**已到期的任务**从定时队列提取到普通任务队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">runAllTasks</span><span class="params">(<span class="type">long</span> timeoutNanos)</span> &#123;</span><br><span class="line">    <span class="comment">// 步骤1：将定时任务队列中已到期的任务转移到普通任务队列</span></span><br><span class="line">    <span class="built_in">this</span>.fetchFromScheduledTaskQueue();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤2：获取第一个任务</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.afterRunningAllTasks(); <span class="comment">// 无任务时执行收尾工作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤3：计算任务执行的截止时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timeoutNanos &gt; <span class="number">0L</span> ? <span class="built_in">this</span>.getCurrentTimeNanos() + timeoutNanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">runTasks</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 记录已执行的任务数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤4：循环执行任务，直到超时或队列为空</span></span><br><span class="line">    <span class="type">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        safeExecute(task); <span class="comment">// 安全执行任务</span></span><br><span class="line">        ++runTasks;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每执行64个任务检查一次超时（批量执行优化）</span></span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">63L</span>) == <span class="number">0L</span>) &#123;</span><br><span class="line">            lastExecutionTime = <span class="built_in">this</span>.getCurrentTimeNanos();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 超时，退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取下一个任务</span></span><br><span class="line">        task = <span class="built_in">this</span>.pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = <span class="built_in">this</span>.getCurrentTimeNanos();</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 队列为空，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤5：执行收尾工作并记录执行时间</span></span><br><span class="line">    <span class="built_in">this</span>.afterRunningAllTasks();</span><br><span class="line">    <span class="built_in">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="nioeventloopgroup">NioEventLoopGroup</span></h2><p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZhuChangwu/p/11192219.html">https://www.cnblogs.com/ZhuChangwu/p/11192219.html</a></p>
<p>NioEventLoopGroup 是 Netty 框架中处理网络 IO 操作的核心组件，它管理一组 NioEventLoop 实例，负责注册 Channel、处理 IO 事件和执行任务</p>
<p><img src="/./../images/image-20250518112706134.png" alt="image-20250518112706134"></p>
<h3><span id="重要字段">重要字段</span></h3><h4><span id="1-线程池相关字段">1. <strong>线程池相关字段</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] children;         <span class="comment">// 管理的 EventLoop 数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;EventExecutor&gt; readonlyChildren; <span class="comment">// 只读视图</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutorChooserFactory.EventExecutorChooser chooser; <span class="comment">// 线程选择器</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>children</strong>：存储所有 NioEventLoop 实例，负责实际的 IO 操作和任务执行。</li>
<li><strong>chooser</strong>：负责从 children 中选择一个 EventLoop，实现负载均衡。</li>
</ul>
<h4><span id="2-线程配置字段">2. <strong>线程配置字段</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> nThreads;                     <span class="comment">// 线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;                <span class="comment">// 任务执行器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutorGroup parent;        <span class="comment">// 父级 EventLoopGroup</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>nThreads</strong>：指定线程池大小，默认是 CPU 核心数的两倍（<code>Runtime.getRuntime().availableProcessors() * 2</code>）。</li>
<li><strong>executor</strong>：实际执行任务的线程池，默认使用 <code>ThreadPerTaskExecutor</code>。</li>
</ul>
<h4><span id="3-selector-配置字段">3. <strong>Selector 配置字段</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;        <span class="comment">// JDK Selector 提供者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory; <span class="comment">// 选择策略工厂</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>provider</strong>：创建 JDK NIO Selector 的工厂，默认使用系统默认实现。</li>
<li><strong>selectStrategyFactory</strong>：创建选择策略，控制 EventLoop 的 select 行为。</li>
</ul>
<h4><span id="4-拒绝策略和任务队列字段">4. <strong>拒绝策略和任务队列字段</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler; <span class="comment">// 任务拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopTaskQueueFactory taskQueueFactory;         <span class="comment">// 任务队列工厂</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>rejectedExecutionHandler</strong>：当任务队列已满时的拒绝策略，默认使用 <code>AbortPolicy</code>。</li>
</ul>
<h3><span id="重要方法"><strong>重要方法</strong></span></h3><h4><span id="1-构造方法">1. <strong>构造方法</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, SelectorProvider provider)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始化 EventLoopGroup，指定线程数、执行器和 Selector 提供者等参数。</li>
</ul>
<h4><span id="2-线程选择方法">2. <strong>线程选择方法</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从 children 数组中选择一个 EventLoop，通过 <code>chooser</code> 实现负载均衡。</li>
</ul>
<h4><span id="3-channel-注册方法">3. <strong>Channel 注册方法</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将 Channel 注册到一个 EventLoop 的 Selector 上，返回异步注册结果。</li>
</ul>
<h4><span id="4-优雅关闭方法">4. <strong>优雅关闭方法</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; shutdownGracefully()</span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; shutdownGracefully(<span class="type">long</span> quietPeriod, <span class="type">long</span> timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<ul>
<li>优雅关闭线程池，允许在指定时间内完成未执行的任务。</li>
</ul>
<h4><span id="5-任务提交方法">5. <strong>任务提交方法</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; execute(Runnable task)</span><br></pre></td></tr></table></figure>

<ul>
<li>向 EventLoop 提交任务，由线程池异步执行。</li>
</ul>
<h4><span id="6-资源清理方法">6. <strong>资源清理方法</strong></span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>清理资源，关闭所有 EventLoop 和 Selector。</li>
</ul>
<h3><span id="工作流程"><strong>工作流程</strong></span></h3><ol>
<li><strong>初始化阶段</strong>：<ul>
<li>创建并启动指定数量的 NioEventLoop 线程。</li>
<li>初始化线程选择器 <code>chooser</code>，用于负载均衡。</li>
</ul>
</li>
<li><strong>Channel 注册阶段</strong>：<ul>
<li>调用 <code>register(Channel)</code> 方法将 Channel 注册到一个 EventLoop。</li>
<li>EventLoop 将 Channel 注册到其管理的 Selector 上。</li>
</ul>
</li>
<li><strong>IO 事件处理阶段</strong>：<ul>
<li>EventLoop 不断循环调用 <code>Selector.select()</code> 方法检测就绪事件。</li>
<li>处理就绪的 IO 事件（读 &#x2F; 写），并执行相应的 ChannelHandler。</li>
</ul>
</li>
<li><strong>任务执行阶段</strong>：<ul>
<li>通过 <code>execute()</code> 或 <code>submit()</code> 方法提交的任务在 EventLoop 线程中执行。</li>
<li>定时任务由 ScheduledExecutorService 管理和执行。</li>
</ul>
</li>
<li><strong>关闭阶段</strong>：<ul>
<li>调用 <code>shutdownGracefully()</code> 方法优雅关闭线程池。</li>
<li>释放所有资源，包括 Selector 和线程。</li>
</ul>
</li>
</ol>
<h3><span id="初始化逻辑">初始化逻辑</span></h3><p><img src="/./../images/image-20250518120624540.png" alt="image-20250518120624540"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化多线程事件执行器组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads         线程数量，必须为正数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor         用于执行任务的基础线程池，若为null则创建默认实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chooserFactory   执行器选择工厂，用于从多个执行器中选择一个处理任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args             创建子执行器时传递的可选参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">    <span class="comment">// 原子计数器，记录已终止的子执行器数量</span></span><br><span class="line">    <span class="built_in">this</span>.terminatedChildren = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">// 异步终止承诺，用于通知整个执行器组已完全终止</span></span><br><span class="line">    <span class="built_in">this</span>.terminationFuture = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验线程数量为正数</span></span><br><span class="line">    ObjectUtil.checkPositive(nThreads, <span class="string">&quot;nThreads&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若未提供基础线程池，则创建默认实现（为每个任务创建新线程）</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(<span class="built_in">this</span>.newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建指定数量的子执行器数组</span></span><br><span class="line">    <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环创建并初始化所有子执行器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; ++i) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inTryBlock</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inTryBlock = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 创建子执行器实例（由子类实现具体逻辑）</span></span><br><span class="line">            <span class="built_in">this</span>.children[i] = <span class="built_in">this</span>.newChild((Executor)executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            inTryBlock = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 若创建失败，抛出异常并终止已创建的子执行器</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 若在try块中且创建失败，优雅关闭已创建的子执行器</span></span><br><span class="line">            <span class="keyword">if</span> (inTryBlock &amp;&amp; !success) &#123;</span><br><span class="line">                <span class="comment">// 发起优雅关闭请求</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 等待所有已创建的子执行器完全终止</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                    <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> <span class="built_in">this</span>.children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待终止（超时时间设为极大值，等效于无限等待）</span></span><br><span class="line">                        <span class="keyword">while</span>(!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(<span class="number">2147483647L</span>, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                        <span class="comment">// 恢复中断状态并退出循环</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若创建失败（finally块外的双重检查），再次确保资源释放</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 与finally块中的逻辑相同，确保资源释放</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="built_in">this</span>.children[j].shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> <span class="built_in">this</span>.children[j];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!e.isTerminated()) &#123;</span><br><span class="line">                        e.awaitTermination(<span class="number">2147483647L</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建执行器选择器，用于从多个子执行器中选择一个处理任务</span></span><br><span class="line">    <span class="built_in">this</span>.chooser = chooserFactory.newChooser(<span class="built_in">this</span>.children);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建终止监听器，当所有子执行器终止时触发</span></span><br><span class="line">    FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> <span class="title class_">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 原子增加已终止子执行器计数，当所有子执行器终止时，标记整个组终止完成</span></span><br><span class="line">            <span class="keyword">if</span> (MultithreadEventExecutorGroup.<span class="built_in">this</span>.terminatedChildren.incrementAndGet() == MultithreadEventExecutorGroup.<span class="built_in">this</span>.children.length) &#123;</span><br><span class="line">                MultithreadEventExecutorGroup.<span class="built_in">this</span>.terminationFuture.setSuccess((Object)<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为每个子执行器注册终止监听器</span></span><br><span class="line">    EventExecutor[] executors = <span class="built_in">this</span>.children;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; executors.length; ++i) &#123;</span><br><span class="line">        <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> executors[i];</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子执行器的只读集合视图，防止外部修改</span></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(<span class="built_in">this</span>.children.length);</span><br><span class="line">    Collections.addAll(childrenSet, <span class="built_in">this</span>.children);</span><br><span class="line">    <span class="built_in">this</span>.readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是：</p>
<h4><span id="1初始化eventloop数组">1.初始化EventLoop数组</span></h4><p>根据传递进来的线程数，创建<code>EventLoop</code>，将<code>EventLoop</code>存储在一个<code>EventExecutor[]</code>数组(即<code>children</code>)中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.children[i] = <span class="built_in">this</span>.newChild((Executor)executor, args);</span><br></pre></td></tr></table></figure>

<p>这个<code>newChild</code>方法调用的是<code>MultithreadEventExecutorGroup</code>里面的<code>newChild</code>方法返回的是一个<code>EventExecutor</code>，<code>EventLoop</code>接口继承了<code>EventExecutor</code>，所以这个<code>EventExecutor</code>其实是一个<code>EventLoop</code>对象</p>
<p><img src="/./../images/image-20250518122317471.png" alt="image-20250518122317471"></p>
<h4><span id="3初始化选择器chooser"><strong>3</strong>.<strong>初始化选择器chooser</strong>：</span></h4><p>这个<code>chooser</code>是一个<code>EventExecutorChooserFactory.EventExecutorChooser</code>对象，这个对象提供了一个<code>next</code>方法，返回的是<code>EventExecutor</code>对象，所以这个选择器用于从<code>EventLoopGroup</code>中选取一个<code>EventLoop</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.chooser = chooserFactory.newChooser(<span class="built_in">this</span>.children);</span><br></pre></td></tr></table></figure>

<h3><span id="核心逻辑">核心逻辑</span></h3><p>当<code>NioEventLoopGroup</code>接收客户端的连接时，会先分配一个<code>NioEventLoop</code>给当前的客户端，当前这个线程池会将客户端<code>channel</code>传递给<code>NioEventLoop</code>，这个<code>NioEventLoop</code>会将调用<code>SingleThreadEventLoop</code>的<code>register</code>方法将当前的客户端注册到当前的<code>NIOEventLoop</code>中</p>
<p><code>SingleThreadEventLoop.register</code>:</p>
<blockquote>
<ol>
<li><p><strong>参数检查</strong>：确保 <code>promise</code> 不为空。</p>
</li>
<li><p><strong>获取 Unsafe 对象</strong>: <code>promise.channel().unsafe()</code></p>
<p>获取 Channel 的内部 Unsafe 实现。</p>
<ul>
<li><strong>Unsafe</strong>：是 Netty 内部使用的接口，提供了底层操作的能力，如注册、绑定、读写等。</li>
</ul>
</li>
<li><p><strong>调用 Unsafe.register ()</strong></p>
<ul>
<li>将当前 <code>NioEventLoopGroup</code> 中的一个 EventLoop（通过 <code>next()</code> 方法选择）传递给 Unsafe。</li>
<li>Unsafe 实现会负责实际的注册操作。</li>
</ul>
</li>
<li><p><strong>返回 Promise</strong>：返回原始的 promise 对象，用于异步获取注册结果。</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChannelPromise promise：一个异步操作的承诺对象，用于跟踪注册操作的完成状态和结果</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查 promise 不为空</span></span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取 Channel 的 Unsafe 对象并调用其 register 方法</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个方法最终会调用<code>AbstractChannel.AbstractUnsafe.register</code>（处理具体的注册逻辑）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Channel 注册到指定的 EventLoop 上</span></span><br><span class="line"><span class="comment"> * 此方法是 Channel 注册流程的核心入口，负责初始化 Channel 与 EventLoop 的关联</span></span><br><span class="line"><span class="comment"> * 并确保注册操作在线程安全的环境中执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eventLoop 目标 EventLoop，Channel 将注册到该 EventLoop 管理的 Selector 上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> promise 用于异步通知注册结果的 Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查参数有效性</span></span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保 Channel 尚未注册</span></span><br><span class="line">    <span class="keyword">if</span> (AbstractChannel.<span class="built_in">this</span>.isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证 EventLoop 类型兼容性（例如 NioEventLoop 只能处理 NIO 类型的 Channel）</span></span><br><span class="line">    <span class="keyword">if</span> (!AbstractChannel.<span class="built_in">this</span>.isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Channel 与指定的 EventLoop 关联</span></span><br><span class="line">    <span class="comment">// 这一步确保后续所有操作都在同一个 EventLoop 线程中执行</span></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查当前线程是否是目标 EventLoop 的线程</span></span><br><span class="line">    <span class="comment">// Netty 要求所有 Channel 操作必须在其关联的 EventLoop 线程中执行</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程是 EventLoop 线程，直接执行注册逻辑</span></span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是 EventLoop 线程，则将注册任务封装为 Runnable 提交到 EventLoop</span></span><br><span class="line">        <span class="comment">// 确保注册操作在 EventLoop 线程中执行，保证线程安全</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 处理任务提交失败的情况（例如 EventLoop 已关闭）</span></span><br><span class="line">            logger.warn(<span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>, </span><br><span class="line">                        AbstractChannel.<span class="built_in">this</span>, t);</span><br><span class="line">            <span class="comment">// 强制关闭 Channel</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            AbstractChannel.<span class="built_in">this</span>.closeFuture.setClosed();</span><br><span class="line">            <span class="comment">// 标记 Promise 为失败状态</span></span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行实际的注册操作（由 register() 方法调用）</span></span><br><span class="line"><span class="comment"> * 此方法会完成 JDK NIO Channel 到 Selector 的注册</span></span><br><span class="line"><span class="comment"> * 并触发 ChannelPipeline 中的注册完成事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记首次注册状态</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 JDK NIO 底层注册操作</span></span><br><span class="line">        <span class="comment">// 将 Channel 注册到 EventLoop 的 Selector 上，初始不监听任何事件（ops=0）</span></span><br><span class="line">        doRegister();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新注册状态</span></span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 触发 ChannelPipeline 中所有添加的 ChannelHandler 的初始化逻辑</span></span><br><span class="line">        <span class="comment">// 确保所有 handlerAdded() 方法被调用</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 安全地标记 Promise 为成功状态</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 触发 ChannelRegistered 事件，通知所有 Handler 通道已注册</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 Channel 已处于活跃状态（例如客户端 Channel 已连接）</span></span><br><span class="line">        <span class="comment">// 则触发 ChannelActive 事件</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                <span class="comment">// 首次注册且已激活，触发 ChannelActive 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// 非首次注册但配置了自动读取，开始读取数据</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 处理注册过程中发生的异常</span></span><br><span class="line">        <span class="comment">// 包括 JDK NIO 注册失败、Handler 初始化异常等</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 强制关闭 Channel</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记关闭状态</span></span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 安全地标记 Promise 为失败状态</span></span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>假设</strong>：</p>
<ul>
<li><code>EventLoop</code> 绑定的线程是 <code>Thread-1</code>。</li>
<li>主线程（<code>main</code>）调用 <code>channel.register()</code>。</li>
</ul>
<p><strong>执行流程</strong>：</p>
<ol>
<li>主线程进入 <code>register()</code> 方法。</li>
<li>检查当前线程（<code>main</code>）是否是 <code>EventLoop</code> 线程（<code>Thread-1</code>），发现不是。</li>
<li>将 <code>register0()</code> 封装成任务，提交到 <code>EventLoop</code> 的任务队列。</li>
<li><code>Thread-1</code> 从队列中取出任务并执行 <code>register0()</code>。</li>
</ol>
<p>注册完成后会触发pipeline.fireChannelActive();会调用AbstractChannelHandlerContext.invokeChannelActive</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态工具方法：确保在正确的事件循环中调用 ChannelActive 事件</span></span><br><span class="line"><span class="comment"> * 根据执行器所在线程决定是直接调用还是提交异步任务执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 执行策略：</span></span><br><span class="line"><span class="comment"> * - 如果当前线程是处理器的事件循环线程，则直接同步调用</span></span><br><span class="line"><span class="comment"> * - 否则将调用封装为任务提交到事件循环线程执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 要调用的下一个 ChannelHandlerContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EventExecutor#inEventLoop()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取处理器关联的事件执行器</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断当前线程是否为事件循环线程</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 直接在当前线程调用，避免线程切换开销</span></span><br><span class="line">        next.invokeChannelActive();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 提交到事件循环线程异步执行</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 触发当前处理器的 ChannelActive 事件处理逻辑</span></span><br><span class="line"><span class="comment"> * 根据处理器类型调用对应实现，并处理可能的异常</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 执行流程：</span></span><br><span class="line"><span class="comment"> * 1. 判断当前处理器是否应该处理该事件</span></span><br><span class="line"><span class="comment"> * 2. 根据处理器类型选择具体的调用方式：</span></span><br><span class="line"><span class="comment"> *    - 头部处理器：直接调用 HeadContext 的实现</span></span><br><span class="line"><span class="comment"> *    - 双向处理器：调用 ChannelDuplexHandler 的实现</span></span><br><span class="line"><span class="comment"> *    - 默认情况：调用 ChannelInboundHandler 的实现</span></span><br><span class="line"><span class="comment"> * 3. 捕获并处理所有异常，确保事件流不中断</span></span><br><span class="line"><span class="comment"> * 4. 若当前处理器不处理，则将事件传播到下一个处理器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ChannelHandler#channelActive(ChannelHandlerContext)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeChannelActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否应由当前处理器处理事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取当前处理器实例</span></span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.handler();</span><br><span class="line">            <span class="comment">// 获取pipeline头部处理器引用</span></span><br><span class="line">            DefaultChannelPipeline.<span class="type">HeadContext</span> <span class="variable">headContext</span> <span class="operator">=</span> <span class="built_in">this</span>.pipeline.head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据处理器类型选择调用方式</span></span><br><span class="line">            <span class="keyword">if</span> (handler == headContext) &#123;</span><br><span class="line">                <span class="comment">// 头部处理器特殊处理（如网络IO操作）</span></span><br><span class="line">                headContext.channelActive(<span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelDuplexHandler) &#123;</span><br><span class="line">                <span class="comment">// 双向处理器支持完整的入站/出站操作</span></span><br><span class="line">                ((ChannelDuplexHandler)handler).channelActive(<span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 默认作为入站处理器处理</span></span><br><span class="line">                ((ChannelInboundHandler)handler).channelActive(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="comment">// 异常处理机制确保事件处理流程不中断</span></span><br><span class="line">            <span class="built_in">this</span>.invokeExceptionCaught(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将事件传播到下一个处理器</span></span><br><span class="line">        <span class="built_in">this</span>.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头部处理器：</p>
<p>是Netty 底层 I&#x2F;O 操作的入口和出口，负责处理与物理通道（如 TCP 连接）直接相关的操作，并衔接上层业务处理器、、</p>
<h2><span id="abstractchannel">AbstractChannel</span></h2><p><code>AbstractChannel</code> 是 Netty 框架中的一个抽象类，它在 Netty 的网络通信中扮演着非常重要的角色，是所有具体通道实现类的基类</p>
<p><code>AbstractChannel</code> 类是 Netty 框架中实现网络通信的基础，它提供了通道的基本抽象和功能，为上层应用提供了一个统一的、高效的网络编程接口。通过继承 <code>AbstractChannel</code>，Netty 实现了多种不同类型的通道（如 <code>NioServerSocketChannel</code>、<code>NioSocketChannel</code> 等</p>
<h3><span id="属性字段">属性字段</span></h3><table>
<thead>
<tr>
<th><strong>字段名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>核心作用</strong></th>
<th><strong>设计要点 &#x2F; 场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>parent</code></td>
<td><code>Channel</code></td>
<td>父通道引用（如服务器通道对应的客户端通道）</td>
<td>用于层级管理，父通道关闭时可级联关闭子通道</td>
</tr>
<tr>
<td><code>id</code></td>
<td><code>ChannelId</code></td>
<td>通道全局唯一标识符</td>
<td>基于 UUID 生成，用于日志、监控标识特定连接</td>
</tr>
<tr>
<td><code>unsafe</code></td>
<td><code>Channel.Unsafe</code></td>
<td>底层传输操作接口（如 Java NIO 的 <code>Selector</code> 操作）</td>
<td>解耦 Netty 抽象层与具体 IO 模型（NIO&#x2F;Epoll），提供 <code>read()</code>、<code>write()</code> 等底层方法</td>
</tr>
<tr>
<td><code>pipeline</code></td>
<td><code>DefaultChannelPipeline</code></td>
<td>处理器链（<code>ChannelHandler</code> 链表）</td>
<td>处理入站 &#x2F; 出站事件，支持动态添加 &#x2F; 删除处理器，实现业务逻辑与 IO 的解耦</td>
</tr>
<tr>
<td><code>closeFuture</code></td>
<td><code>CloseFuture</code></td>
<td>通道关闭事件的异步通知机制</td>
<td>基于 <code>Future-Listener</code> 模式，支持非阻塞式关闭回调（如资源释放）</td>
</tr>
<tr>
<td><code>eventLoop</code></td>
<td><code>EventLoop</code></td>
<td>关联的事件循环线程（<code>NioEventLoop</code> 等）</td>
<td>通道的所有 IO 操作必须在此线程执行，确保线程安全</td>
</tr>
<tr>
<td><code>registered</code></td>
<td><code>boolean</code></td>
<td>标识通道是否已注册到 <code>Selector</code></td>
<td><code>true</code> 表示可开始监听 IO 事件（如 <code>OP_READ</code>），由 <code>register()</code> 方法更新</td>
</tr>
<tr>
<td><code>localAddress</code></td>
<td><code>SocketAddress</code></td>
<td>本地绑定地址（如服务器端口）</td>
<td>绑定端口后设置（如 <code>0.0.0.0:8080</code>）</td>
</tr>
<tr>
<td><code>remoteAddress</code></td>
<td><code>SocketAddress</code></td>
<td>远程连接地址（如客户端 IP + 端口）</td>
<td>客户端连接建立后设置（如 <code>192.168.1.1:50000</code>）</td>
</tr>
<tr>
<td><code>unsafeVoidPromise</code></td>
<td><code>VoidChannelPromise</code></td>
<td>空操作的 <code>ChannelPromise</code>（占位符）</td>
<td>用于不需要返回结果的操作（如内部清理），避免创建临时对象</td>
</tr>
<tr>
<td><code>closeInitiated</code></td>
<td><code>boolean</code></td>
<td>标识是否已发起关闭流程</td>
<td>防止重复关闭，确保关闭逻辑幂等性</td>
</tr>
<tr>
<td><code>initialCloseCause</code></td>
<td><code>Throwable</code></td>
<td>关闭原因（异常信息）</td>
<td></td>
</tr>
</tbody></table>
<h3><span id="方法">方法</span></h3><table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th><strong>参数</strong></th>
<th><strong>返回值</strong></th>
<th><strong>核心功能</strong></th>
<th><strong>设计要点 &#x2F; 典型场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>register(EventLoop, Promise)</code></td>
<td><code>EventLoop</code>, <code>ChannelPromise</code></td>
<td><code>void</code></td>
<td>将通道注册到指定 <code>EventLoop</code> 的 <code>Selector</code> 上</td>
<td>线程安全设计：若当前线程不是 <code>EventLoop</code> 线程，通过 <code>execute()</code> 提交任务确保单线程执行</td>
</tr>
<tr>
<td><code>bind(SocketAddress, Promise)</code></td>
<td><code>SocketAddress</code>, <code>ChannelPromise</code></td>
<td><code>ChannelFuture</code></td>
<td>绑定本地地址（如服务器端口）</td>
<td>异步操作：返回 <code>ChannelFuture</code> 监听绑定结果，内部调用 <code>doBind()</code> 实现具体逻辑</td>
</tr>
<tr>
<td><code>connect(SocketAddress, Promise)</code></td>
<td><code>SocketAddress</code>, <code>ChannelPromise</code></td>
<td><code>ChannelFuture</code></td>
<td>连接远程地址（客户端模式）</td>
<td>异步操作：支持超时设置，内部调用 <code>doConnect()</code> 实现具体连接逻辑</td>
</tr>
<tr>
<td><code>disconnect(Promise)</code></td>
<td><code>ChannelPromise</code></td>
<td><code>ChannelFuture</code></td>
<td>断开连接（客户端模式）</td>
<td>通常用于主动关闭连接，释放资源，内部调用 <code>doDisconnect()</code></td>
</tr>
<tr>
<td><code>close(Promise)</code></td>
<td><code>ChannelPromise</code></td>
<td><code>ChannelFuture</code></td>
<td>关闭通道（优雅关闭）</td>
<td>触发 <code>pipeline</code> 的 <code>channelInactive()</code> 事件，确保所有处理器有机会执行清理逻辑</td>
</tr>
<tr>
<td><code>write(Object, Promise)</code></td>
<td><code>Object</code>（消息）, <code>ChannelPromise</code></td>
<td><code>ChannelFuture</code></td>
<td>将消息写入通道（异步操作）</td>
<td>消息从 <code>pipeline</code> 的尾部开始流动，最终调用 <code>unsafe.write()</code> 执行底层写操作</td>
</tr>
<tr>
<td><code>flush()</code></td>
<td><code>void</code></td>
<td><code>Channel</code></td>
<td>强制刷新缓冲区，将数据发送到网络</td>
<td>通常与 <code>write()</code> 配合使用（如 <code>writeAndFlush()</code>），触发 <code>pipeline</code> 的 <code>flush()</code> 事件</td>
</tr>
<tr>
<td><code>read()</code></td>
<td><code>void</code></td>
<td><code>Channel</code></td>
<td>触发通道读取数据（从网络接收数据）</td>
<td>调用 <code>pipeline</code> 的 <code>read()</code> 事件，最终调用 <code>unsafe.beginRead()</code> 注册 <code>OP_READ</code> 事件</td>
</tr>
<tr>
<td><code>pipeline()</code></td>
<td><code>void</code></td>
<td><code>ChannelPipeline</code></td>
<td>获取通道的 <code>ChannelPipeline</code>（处理器链）</td>
<td>线程安全：每个通道有独立的 <code>pipeline</code>，支持动态添加 &#x2F; 删除处理器</td>
</tr>
<tr>
<td><code>config()</code></td>
<td><code>void</code></td>
<td><code>ChannelConfig</code></td>
<td>获取通道配置（如 <code>TCP_NODELAY</code>、<code>SO_KEEPALIVE</code> 等）</td>
<td>配置参数通过 <code>ChannelOption</code> 设置，影响底层 <code>Socket</code> 行为</td>
</tr>
<tr>
<td><code>localAddress()</code></td>
<td><code>void</code></td>
<td><code>SocketAddress</code></td>
<td>获取本地绑定地址</td>
<td>绑定后返回 <code>localAddress</code> 字段值，否则返回 <code>null</code></td>
</tr>
<tr>
<td><code>remoteAddress()</code></td>
<td><code>void</code></td>
<td><code>SocketAddress</code></td>
<td>获取远程连接地址</td>
<td>连接建立后返回 <code>remoteAddress</code> 字段值，否则返回 <code>null</code></td>
</tr>
<tr>
<td><code>isActive()</code></td>
<td><code>void</code></td>
<td><code>boolean</code></td>
<td>判断通道是否处于活跃状态（已连接或已绑定）</td>
<td>通常用于检查通道是否可进行读写操作</td>
</tr>
</tbody></table>
<h2><span id="netty服务器启动源码剖析">Netty服务器启动源码剖析</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并配置Netty服务器</span></span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"><span class="comment">// 设置服务器的BossGroup和WorkGroup</span></span><br><span class="line">server.group(bossGroup, workGroups);</span><br><span class="line"><span class="comment">// 指定服务器的通道类型</span></span><br><span class="line">server.channel(NioServerSocketChannel.class);</span><br><span class="line"><span class="comment">// 2.配置服务器的处理器</span></span><br><span class="line"><span class="comment">// 2.1. 主通道处理器（用于ServerSocketChannel，处理连接建立事件）</span></span><br><span class="line">server.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioServerSocketChannel ch)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置主通道的处理器链（如日志记录、连接限制等）</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.2. 子通道处理器（用于SocketChannel，处理读写事件）</span></span><br><span class="line">ChannelInitializer&lt;SocketChannel&gt; childHandlers = <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置SocketChannel的管道</span></span><br><span class="line">        socketChannel.pipeline().addLast(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StringDecoder</span>(), <span class="comment">// 字符串解码器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StringEncoder</span>(), <span class="comment">// 字符串编码器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ChatServerHandler</span>(), <span class="comment">// 自定义处理器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ChatConnectionServerHandler</span>() <span class="comment">// 监听客户端状态</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">server.childHandler(childHandlers);</span><br><span class="line"><span class="comment">// 设置服务器的配置项</span></span><br><span class="line">server.option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">        .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.绑定端口并启动服务</span></span><br><span class="line"><span class="type">ChannelFuture</span> <span class="variable">serverChannel</span> <span class="operator">=</span> server.bind(port).sync();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.等待服务器关闭</span></span><br><span class="line">serverChannel.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>

<ol>
<li>**创建并初始化 <code>ServerSocketChannel</code>**：<ul>
<li><code>ServerBootstrap</code> 根据配置创建一个 <code>ServerSocketChannel</code>，用于监听客户端连接。</li>
<li>配置 <code>ServerSocketChannel</code> 的一些参数，如 <code>SO_BACKLOG</code>（连接队列长度）等。</li>
</ul>
</li>
<li>**将 <code>ServerSocketChannel</code> 注册到 <code>EventLoop</code>**：<ul>
<li><code>ServerSocketChannel</code> 会被注册到 <code>EventLoop</code> 的 <code>Selector</code> 上，以便监听连接事件。</li>
<li>注册过程是异步的，通过 <code>ChannelFuture</code> 来通知注册结果。</li>
</ul>
</li>
<li><strong>绑定端口</strong>：<ul>
<li>调用 <code>ServerSocketChannel</code> 的 <code>bind</code> 方法，将其绑定到指定的端口。</li>
<li>底层会调用操作系统的 <code>bind</code> 系统调用，将套接字绑定到指定的 IP 地址和端口。</li>
</ul>
</li>
<li><strong>启动监听</strong>：<ul>
<li>绑定成功后，<code>ServerSocketChannel</code> 开始监听客户端连接。</li>
<li>此时，<code>ServerSocketChannel</code> 处于 <code>OP_ACCEPT</code> 状态，等待客户端连接。</li>
</ul>
</li>
<li><strong>阻塞等待绑定完成</strong>：<ul>
<li><code>sync()</code> 方法会阻塞当前线程，直到绑定操作完成。</li>
<li>如果绑定成功，<code>ChannelFuture</code> 的 <code>isSuccess()</code> 方法返回 <code>true</code>；如果绑定失败，<code>ChannelFuture</code> 的 <code>isSuccess()</code> 方法返回 <code>false</code>，并且可以通过 <code>cause()</code> 方法获取失败原因。</li>
</ul>
</li>
<li><strong>触发 <code>ChannelActive</code> 事件</strong>：<ul>
<li>如果 <code>Channel</code> 在绑定后变为活跃状态（之前不活跃），会异步触发 <code>ChannelActive</code> 事件。</li>
<li><code>ChannelActive</code> 事件会被传播到 <code>ChannelPipeline</code> 中的所有 <code>ChannelHandler</code>，以便它们可以执行相应的初始化或处理逻辑。</li>
</ul>
</li>
</ol>
<p><img src="/./../images/image-20250518125459436.png" alt="image-20250518125459436"></p>
<h3><span id="1初始化eventloopgroup">1.初始化EventLoopGroup</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.group(bossGroup, workerGroups);</span><br></pre></td></tr></table></figure>

<p>调用<code>ServerBootStrap</code>的<code>group</code>方法指定<code>bossGroup</code>和<code>workerGroup</code></p>
<ul>
<li><code>workerGroup</code>会传递给<code>ServerBootStrap</code>类，指定<code>childGroup</code>为<code>workerGroup</code></li>
<li><code>bossGroup</code>会传递给<code>AbstractBootstrap</code>这个类，指定这个类的<code>group</code>属性为传递的<code>bossGroup</code></li>
</ul>
<p>（<code>ServerBootStrap</code>类继承了<code>AbstractBootstrap</code>类）</p>
<p><strong>一般情况下：</strong></p>
<p><code>bossGroup</code>可以认为是主<code>Reactor</code>线程池，主要负责处理客户端的<strong>连接请求</strong>（<code>accept</code>事件），建立与客户端的连接</p>
<p><code>workerGroup</code>可以认为是从<code>Reactor</code>线程池。主要负责处理<strong>已建立连接的 <code>Channel</code> 的读写事件</strong>（<code>read/write</code>事件），包括数据的接收、处理和发送</p>
<h3><span id="2初始化channel">2.初始化channel</span></h3><p>主要是设置<code>AbstractBootstrap</code>里面的<code>channelFactory</code>属性设置为对应通道类型的工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.channel(NioServerSocketChannel.class);</span><br></pre></td></tr></table></figure>

<p>调用的是父类<code>AbstractBootstrap</code>的<code>channel</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((io.netty.channel.ChannelFactory)(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>((Class)ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((ChannelFactory)channelFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReflectiveChannelFactory</code> 是 Netty 中用于<strong>通过反射创建 Channel 实例</strong>的工厂类</p>
<p><code>ReflectiveChannelFactory</code>通过<code>channelClass</code>（当前通道的类型）通过反射拿到对应类（当前通道）的无参构造器</p>
<p><code>ReflectiveChannelFactory</code>实现了<code>ChannelFactory</code>接口，所以它是<code>ChannelFactory</code>的子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) + <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>channelFactory</code>方法将当前类的<code>channelFactory</code>属性初始化为<code>ReflectiveChannelFactory</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ChannelFactory</code>接口提供了一个<code>newChannel</code>方法，这个方法对应的实现类是<code>ReflectiveChannelFactory</code>，这个方法返回通过反射拿到的构造器创建对应通道类型的实例（即NioServerSocketChannel实例）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">newChannel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Channel)<span class="built_in">this</span>.constructor.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Unable to create Channel from class &quot;</span> + <span class="built_in">this</span>.constructor.getDeclaringClass(), var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3初始化处理器">3.初始化处理器</span></h3><p>在 Netty 中，**<code>ChannelInitializer</code>** 是一个核心组件，用于<strong>动态初始化 Channel 的处理器链（<code>ChannelPipeline</code>）</strong></p>
<p>会在 Channel 注册到<code>EventLoop</code>后、真正开始处理数据前，动态添加处理器</p>
<p>当 Channel 注册到<code>EventLoop</code>时，<code>ChannelInitializer</code>的<code>initChannel()</code>方法会被触发，会调用<code>AbstractChannel</code>类的<code>pipeline</code>方法给当前Channel的<code>ChannelPipeline</code>对象（即<code>pipeline</code>）添加处理器链</p>
<p><img src="/./../images/image-20250518135552301.png" alt="image-20250518135552301"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 配置SocketChannel的管道</span></span><br><span class="line">    socketChannel.pipeline().addLast(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StringDecoder</span>(), <span class="comment">// 字符串解码器</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StringEncoder</span>(), <span class="comment">// 字符串编码器</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatServerHandler</span>(), <span class="comment">// 自定义处理器</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatConnectionServerHandler</span>() <span class="comment">// 监听客户端状态</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(handlers, <span class="string">&quot;handlers&quot;</span>);</span><br><span class="line">    ChannelHandler[] var3 = handlers;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> handlers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        <span class="type">ChannelHandler</span> <span class="variable">h</span> <span class="operator">=</span> var3[var5];</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.addLast(executor, (String)<span class="literal">null</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="初始化主通道处理器handler">初始化主通道处理器(handler())</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 主通道处理器（用于ServerSocketChannel，处理连接建立事件）</span></span><br><span class="line">server.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioServerSocketChannel ch)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置主通道的处理器链（如日志记录、连接限制等）</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>调用入口是<code>AbstractBootstrap类</code>的<code>handler</code>方法，将<code>AbstractBootstrap类</code>的<code>handler属性</code>设置为传入的处理器，主要用于处理<code>bossGroup</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">handler</span><span class="params">(ChannelHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handler = (ChannelHandler)ObjectUtil.checkNotNull(handler, <span class="string">&quot;handler&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5><span id="初始化子通道处理器childhandler">初始化子通道处理器(childHandler())</span></h5><p>客户端连接服务器时，为客户端通道添加处理器链</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 子通道处理器（用于SocketChannel，处理读写事件）</span></span><br><span class="line">ChannelInitializer&lt;SocketChannel&gt; childHandlers = <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置SocketChannel的管道</span></span><br><span class="line">        socketChannel.pipeline().addLast(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StringDecoder</span>(), <span class="comment">// 字符串解码器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StringEncoder</span>(), <span class="comment">// 字符串编码器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ChatServerHandler</span>(), <span class="comment">// 自定义处理器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ChatConnectionServerHandler</span>() <span class="comment">// 监听客户端状态</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">server.childHandler(childHandlers);</span><br></pre></td></tr></table></figure>

<p>调用的入口是<code>ServerBootStrap</code>的<code>childHandler</code>方法，主要是将<code>ServerBootStrap</code>的子处理器<code>childHandler</code>设置为传入的处理器</p>
<p>这个子处理器其实就是用于处理<code>workerGroup</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServerBootstrap <span class="title function_">childHandler</span><span class="params">(ChannelHandler childHandler)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.childHandler = (ChannelHandler)ObjectUtil.checkNotNull(childHandler, <span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="4绑定端口并启动服务">4.绑定端口并启动服务</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定端口并启动服务</span></span><br><span class="line"><span class="type">ChannelFuture</span> <span class="variable">serverChannel</span> <span class="operator">=</span> server.bind(port).sync();</span><br></pre></td></tr></table></figure>

<p>调用关系图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心调用链路（简化版）</span></span><br><span class="line"><span class="number">1.</span> ServerBootstrap.bind(port)                <span class="comment">// 用户调用入口</span></span><br><span class="line"><span class="number">2.</span>  -&gt; AbstractBootstrap.doBind(localAddress) <span class="comment">// 启动器内部逻辑</span></span><br><span class="line"><span class="number">3.</span>     -&gt; Channel.bind(localAddress)          <span class="comment">// 通道绑定操作</span></span><br><span class="line"><span class="number">4.</span>       -&gt; ChannelPipeline.bind()            <span class="comment">// 触发 Pipeline 事件</span></span><br><span class="line"><span class="number">5.</span>         -&gt; HeadContext.bind()              <span class="comment">// Pipeline 头部处理器</span></span><br><span class="line"><span class="number">6.</span>           -&gt; NioMessageUnsafe.bind()       <span class="comment">// 底层 unsafe 操作</span></span><br><span class="line"><span class="number">7.</span>             -&gt; ServerSocketChannel.bind()  <span class="comment">// 调用 Java NIO 原生方法</span></span><br><span class="line"><span class="number">8.</span>               -&gt; OS socket.bind()          <span class="comment">// 操作系统系统调用</span></span><br><span class="line"><span class="number">9.</span>               -&gt; OS socket.listen()        <span class="comment">// 操作系统系统调用</span></span><br><span class="line"><span class="number">10.</span> serverChannel.sync()                     <span class="comment">// 阻塞等待绑定完成</span></span><br></pre></td></tr></table></figure>

<p>入口函数：调用AbstractBootstrap的bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(<span class="type">int</span> inetPort)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(inetPort));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.validate();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.doBind((SocketAddress)ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">    <span class="comment">// 步骤1：初始化Channel并注册到EventLoop</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> <span class="built_in">this</span>.initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤2：根据注册结果处理绑定</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture; <span class="comment">// 注册失败，直接返回失败结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// 注册已完成，立即执行绑定</span></span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注册未完成（异步），添加监听器，注册完成后再执行绑定</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PendingRegistrationPromise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingRegistrationPromise</span>(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause); <span class="comment">// 注册失败，传播异常</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise); <span class="comment">// 注册成功，执行绑定</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="41初始化并注册channel">4.1.初始化并注册Channel</span></h4><p><strong>调用AbstractBootstrap的initAndRegister方法</strong></p>
<p>1.通过channelFactory工厂类，创建通道实例channel</p>
<p>2.通过this.init(channel)初始化当前通道，负责初始化服务器 Channel 的各项参数和处理器链。</p>
<p>3.将 Channel 注册到 EventLoopGroup 中的某个 EventLoop</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 Channel 并将其注册到 EventLoopGroup，为后续的网络通信做准备。</span></span><br><span class="line"><span class="comment"> * 这是服务器启动流程中的核心步骤，完成后 Channel 开始监听网络事件。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 表示注册操作的异步结果。成功时可通过 Channel 绑定端口，失败时包含具体异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 通过反射创建 Channel 实例（如 NioServerSocketChannel）</span></span><br><span class="line">        <span class="comment">//    - 此步骤会初始化底层 Java NIO Channel（如 ServerSocketChannel）</span></span><br><span class="line">        <span class="comment">//    - 设置为非阻塞模式并创建对应的 Pipeline</span></span><br><span class="line">        channel = <span class="built_in">this</span>.channelFactory.newChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 初始化 Channel 配置：</span></span><br><span class="line">        <span class="comment">//    - 设置 TCP 参数（如 SO_BACKLOG、SO_REUSEADDR）</span></span><br><span class="line">        <span class="comment">//    - 添加用户通过 handler() 设置的处理器（如 LoggingHandler）</span></span><br><span class="line">        <span class="comment">//    - 对于 ServerBootstrap，会添加 ServerBootstrapAcceptor 用于处理新连接</span></span><br><span class="line">        <span class="built_in">this</span>.init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 初始化失败时，强制关闭 Channel 并返回失败的 ChannelPromise</span></span><br><span class="line">        <span class="comment">// 确保资源正确释放，避免内存泄漏</span></span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若 Channel 创建失败，返回特殊的 FailedChannel 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="keyword">new</span> <span class="title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 Channel 注册到 EventLoopGroup 中的某个 EventLoop：</span></span><br><span class="line">    <span class="comment">//    - 对于 ServerBootstrap，config().group() 返回 bossGroup（处理连接接受的线程池）</span></span><br><span class="line">    <span class="comment">//    - 注册后，EventLoop 开始监听 OP_ACCEPT 事件（对于服务器 Channel）</span></span><br><span class="line">    <span class="comment">//    - 注册是异步操作，通过 ChannelFuture 通知结果</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> <span class="built_in">this</span>.config().group().register(channel);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 注册失败处理：</span></span><br><span class="line">    <span class="comment">//    - 若注册过程中立即发现异常（如 Selector 打开失败）</span></span><br><span class="line">    <span class="comment">//    - 根据 Channel 状态选择优雅关闭或强制关闭</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close(); <span class="comment">// 已注册但失败，执行优雅关闭</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly(); <span class="comment">// 未注册成功，强制关闭</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.通过channelFactory属性创建对应通道类型的实例（channelFactory这个工厂类是在初始化的时候创建的）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel = <span class="built_in">this</span>.channelFactory.newChannel();</span><br></pre></td></tr></table></figure>

<p><strong>2.通过调用ServerBootstrap类的init方法初始化当前通道</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.init(channel);</span><br></pre></td></tr></table></figure>

<p>2.1.<strong>配置服务器 Channel</strong>：设置选项（如 <code>SO_BACKLOG</code>）和属性。</p>
<p>2.2.<strong>构建 Pipeline</strong>：添加主处理器（如 <code>LoggingHandler</code>）和 <code>ServerBootstrapAcceptor</code>。</p>
<p>2.3.<strong>处理新连接</strong>：</p>
<ul>
<li><code>ServerBootstrapAcceptor</code> 负责创建子 Channel（<code>SocketChannel</code>）。</li>
<li>为子 Channel 配置处理器链（如 <code>HttpServerCodec</code>）。</li>
<li>将子 Channel 注册到 <code>childGroup</code> 的 <code>EventLoop</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 设置 Channel 选项（如 TCP 参数）</span></span><br><span class="line">    setChannelOptions(channel, <span class="built_in">this</span>.newOptionsArray(), logger);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 设置 Channel 属性（自定义键值对）</span></span><br><span class="line">    setAttributes(channel, <span class="built_in">this</span>.newAttributesArray());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 获取 Channel 的 Pipeline（处理器链）</span></span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 保存 childGroup 和 childHandler 的引用（用于处理客户端连接）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">currentChildGroup</span> <span class="operator">=</span> <span class="built_in">this</span>.childGroup;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelHandler</span> <span class="variable">currentChildHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.childHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 添加一个特殊的 ChannelInitializer 到 Pipeline</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> &#123;</span><br><span class="line">            <span class="comment">// 5.1 添加用户配置的主处理器（如 LoggingHandler）</span></span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> ServerBootstrap.<span class="built_in">this</span>.config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5.2 添加 ServerBootstrapAcceptor 到 Pipeline（关键组件）</span></span><br><span class="line">            ch.eventLoop().execute(() -&gt; &#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                    ch, currentChildGroup, currentChildHandler, </span><br><span class="line">                    currentChildOptions, currentChildAttrs, extensions</span><br><span class="line">                ));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 调用扩展点（如果有）</span></span><br><span class="line">    <span class="keyword">if</span> (!extensions.isEmpty() &amp;&amp; channel <span class="keyword">instanceof</span> ServerChannel) &#123;</span><br><span class="line">        <span class="comment">// 执行扩展逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServerBootstrapAcceptor</code> 是一个特殊的 <code>ChannelInboundHandler</code>，它作为<strong>连接管理器</strong>存在于 <code>NioServerSocketChannel</code> 的 Pipeline 中，主要负责：</p>
<ul>
<li><strong>接收新连接</strong>：当主 Reactor（<code>bossGroup</code>）检测到客户端连接请求时，创建对应的 <code>NioSocketChannel</code>。</li>
<li><strong>分配 EventLoop</strong>：从从 Reactor（<code>childGroup</code>）中选择一个 <code>EventLoop</code> 分配给新连接。</li>
<li><strong>初始化子 Channel</strong>：为新连接的 <code>NioSocketChannel</code> 配置处理器链（<code>Pipeline</code>）和选项。</li>
<li><strong>注册到 Selector</strong>：将新连接注册到分配的 <code>EventLoop</code> 的 <code>Selector</code> 上，开始监听读写事件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.2 添加 ServerBootstrapAcceptor 到 Pipeline（关键组件）</span></span><br><span class="line">ch.eventLoop().execute(() -&gt; &#123;</span><br><span class="line">    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">        ch, currentChildGroup, currentChildHandler, </span><br><span class="line">        currentChildOptions, currentChildAttrs, extensions</span><br><span class="line">    ));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>当有新客户端连接时，<code>ServerBootstrapAcceptor</code> 的 <code>channelRead()</code> 方法会被触发</strong></p>
<p>核心功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理新连接的核心方法。当主 Reactor（bossGroup）接收到客户端连接时，此方法会被触发，</span></span><br><span class="line"><span class="comment"> * 负责将新连接配置并注册到从 Reactor（workerGroup）。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx 上下文对象，用于与 Pipeline 交互</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg 新连接的 Channel 对象（如 NioSocketChannel）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取新连接的 Channel 对象（代表客户端连接）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">child</span> <span class="operator">=</span> (Channel) msg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 配置子 Channel 的 Pipeline：</span></span><br><span class="line">    <span class="comment">//    - 添加用户通过 childHandler() 设置的处理器链（如 HttpServerCodec、业务处理器）</span></span><br><span class="line">    <span class="comment">//    - 每个新连接都会创建独立的 Pipeline 实例，确保线程安全</span></span><br><span class="line">    child.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelHandler</span>[]&#123;<span class="built_in">this</span>.childHandler&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 设置子 Channel 的 TCP 选项：</span></span><br><span class="line">    <span class="comment">//    - 常见选项：TCP_NODELAY（禁用 Nagle 算法）、SO_KEEPALIVE（启用保活机制）</span></span><br><span class="line">    <span class="comment">//    - 这些选项会影响底层 Socket 的行为</span></span><br><span class="line">    AbstractBootstrap.setChannelOptions(child, <span class="built_in">this</span>.childOptions, ServerBootstrap.logger);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 设置子 Channel 的自定义属性：</span></span><br><span class="line">    <span class="comment">//    - 存储与连接相关的元数据（如认证信息、会话ID）</span></span><br><span class="line">    <span class="comment">//    - 示例：channel.attr(AttributeKey.valueOf(&quot;sessionId&quot;)).set(&quot;12345&quot;);</span></span><br><span class="line">    AbstractBootstrap.setAttributes(child, <span class="built_in">this</span>.childAttrs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 执行扩展逻辑（如果有）：</span></span><br><span class="line">    <span class="comment">//    - 允许用户在 Channel 初始化后执行自定义逻辑</span></span><br><span class="line">    <span class="comment">//    - 例如：添加额外的处理器、修改 Channel 配置</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.extensions.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.extensions.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            <span class="type">ChannelInitializerExtension</span> <span class="variable">extension</span> <span class="operator">=</span> (ChannelInitializerExtension)var4.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                extension.postInitializeServerChildChannel(child);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">                ServerBootstrap.logger.warn(<span class="string">&quot;Exception thrown from postInitializeServerChildChannel&quot;</span>, var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 将子 Channel 注册到 workerGroup 的某个 EventLoop：</span></span><br><span class="line">    <span class="comment">//    - 从 workerGroup 中选择一个 EventLoop（线程）</span></span><br><span class="line">    <span class="comment">//    - 注册后，该 EventLoop 将负责处理此连接的所有 IO 操作（读写、编解码等）</span></span><br><span class="line">    <span class="comment">//    - 注册是异步操作，通过 ChannelFuture 监听结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.childGroup.register(child).addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    <span class="comment">// 注册失败时，强制关闭连接并记录异常</span></span><br><span class="line">                    ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">        <span class="comment">// 注册过程中发生异常，立即关闭连接</span></span><br><span class="line">        forceClose(child, var7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong>3. 将 Channel 注册到 EventLoopGroup 中的某个 EventLoop</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> <span class="built_in">this</span>.config().group().register(channel);</span><br></pre></td></tr></table></figure>

<p>是 Netty 服务器启动流程中的核心操作，负责将 <strong>Channel 注册到 EventLoop 的 Selector</strong>，从而建立事件循环机制。这个操作标志着 Channel 开始真正参与网络 IO 处理。</p>
<p><code>ChannelFuture</code>封装<strong>异步操作结果</strong>：</p>
<ul>
<li><strong>立即返回</strong>：调用 <code>register(channel)</code> 后，方法会立即返回一个 <code>ChannelFuture</code>，此时注册操作可能尚未完成。</li>
<li><strong>异步完成</strong>：Netty 会在后台完成实际的注册操作，完成后通过 <code>ChannelFuture</code> 通知结果。</li>
</ul>
<p> <strong><code>config().group()</code></strong></p>
<ul>
<li>**<code>config()</code>**：返回 <code>AbstractBootstrapConfig</code>，包含启动配置信息。</li>
<li>**<code>group()</code>**：返回EventLoopGroup（线程池）：<ul>
<li>**对于 <code>ServerBootstrap</code>**：<br><code>config().group()</code> 返回 **<code>bossGroup</code>**，负责接受客户端连接。<br>示例：<code>ServerBootstrap.group(bossGroup, workerGroup)</code>。</li>
<li><strong>对于 <code>Bootstrap</code>（客户端）</strong>：<br><code>config().group()</code> 返回唯一的 <code>EventLoopGroup</code>，负责处理所有连接的 IO。</li>
</ul>
</li>
</ul>
<p>这个<code>register</code>方法最终会调用<code>AbstractChannel</code>类的register方法（AbstractChannel类是所有具体通道实现类的基类,定义了通道的一些通用属性和方法），返回一个ChannelFuture对象，</p>
<p>SingleThreadEventLoop.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.register((ChannelPromise)(<span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, <span class="built_in">this</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractChannel.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Channel 注册到指定的 EventLoop，建立事件循环机制。</span></span><br><span class="line"><span class="comment"> * 此方法是线程安全的，确保注册操作在 EventLoop 线程中执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> eventLoop 目标 EventLoop，负责处理 Channel 的所有 IO 操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> promise 用于异步通知注册结果的 Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 校验参数：确保 EventLoop 不为空</span></span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态检查：防止重复注册</span></span><br><span class="line">    <span class="keyword">if</span> (AbstractChannel.<span class="built_in">this</span>.isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Channel 已注册到 EventLoop&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容性检查：确保 EventLoop 类型与 Channel 兼容（如 NioEventLoop 与 NioChannel）</span></span><br><span class="line">    <span class="keyword">if</span> (!AbstractChannel.<span class="built_in">this</span>.isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;不兼容的 EventLoop 类型: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定 EventLoop：将 Channel 与指定的 EventLoop 永久关联</span></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保注册操作在 EventLoop 线程中执行（关键！）</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 当前线程已是 EventLoop 线程，直接执行注册</span></span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前线程不是 EventLoop 线程，提交任务到 EventLoop 的任务队列</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(() -&gt; register0(promise));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 任务提交失败处理</span></span><br><span class="line">            logger.warn(<span class="string">&quot;注册任务被 EventLoop 拒绝，强制关闭 Channel: &#123;&#125;&quot;</span>, </span><br><span class="line">                AbstractChannel.<span class="built_in">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            AbstractChannel.<span class="built_in">this</span>.closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实际执行 Channel 注册到 Selector 的核心方法。</span></span><br><span class="line"><span class="comment"> * 必须在 EventLoop 线程中调用，确保线程安全。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> promise 用于异步通知注册结果的 Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 标记 Promise 为不可取消，并检查 Channel 是否处于打开状态</span></span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 记录是否为首次注册</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 执行底层注册操作（如调用 Java NIO 的 SelectableChannel.register()）</span></span><br><span class="line">        AbstractChannel.<span class="built_in">this</span>.doRegister();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 更新注册状态</span></span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 触发 HandlerAdded 回调（如果有）</span></span><br><span class="line">        <span class="comment">//    确保所有添加到 Pipeline 的 Handler 有机会执行初始化逻辑</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 标记注册成功</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 7. 触发 ChannelRegistered 事件，通知 Pipeline 中的所有 Handler</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 8. 如果 Channel 已处于活跃状态（如客户端已连接），触发相应事件</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                <span class="comment">// 首次注册且已活跃，触发 ChannelActive 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// 非首次注册但配置了自动读取，开始读取数据</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 注册过程中发生异常，强制关闭 Channel</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="42-根据注册结果处理绑定">4.2 根据注册结果处理绑定</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line"><span class="keyword">return</span> promise;</span><br></pre></td></tr></table></figure>

<p>调用AbstractBootstrap类的doBind0()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 Channel 绑定操作的核心逻辑。</span></span><br><span class="line"><span class="comment"> * 确保在 Channel 注册到 EventLoop 成功后，再异步执行绑定操作。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> regFuture 注册操作的 Future 对象，用于判断注册是否成功</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel 待绑定的 Channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localAddress 要绑定的本地地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> promise 绑定操作的 Promise，用于异步通知结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doBind0</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> ChannelFuture regFuture,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> Channel channel,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> SocketAddress localAddress,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 Channel 关联的 EventLoop 线程中执行绑定操作</span></span><br><span class="line">    channel.eventLoop().execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">            <span class="comment">// 注册成功，执行绑定操作，并添加失败自动关闭监听器</span></span><br><span class="line">            channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 注册失败，将注册失败原因传递给绑定 Promise</span></span><br><span class="line">            promise.setFailure(regFuture.cause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>channel.bind会去调用AbstractChannel的pipeline对象，并执行对应的bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行DefaultChannelPipeline类的bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tail是<code>AbstractChannelHandlerContext</code>对象，会调用<code>AbstractChannelHandlerContext</code>类的<code>bind方法</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步绑定 Channel 到指定的本地地址。</span></span><br><span class="line"><span class="comment"> * 通过 ChannelPipeline 触发出站事件，最终由底层传输层执行实际绑定操作。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localAddress 要绑定的本地地址（如 InetSocketAddress）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> promise 用于异步通知绑定结果的 Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回传入的 promise 对象，支持链式调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 校验参数：确保地址不为空</span></span><br><span class="line">    ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证 Promise 有效性（如未取消、与当前 Channel 关联）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isNotValidPromise(promise, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise; <span class="comment">// 无效 Promise，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找 Pipeline 中下一个支持 bind 操作的出站处理器上下文</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> <span class="built_in">this</span>.findContextOutbound(<span class="number">512</span>); <span class="comment">// 512 = BIND 操作掩码</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保在 EventLoop 线程中执行绑定操作（关键！）</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 当前线程已是 EventLoop 线程，直接调用</span></span><br><span class="line">        next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前线程不是 EventLoop 线程，提交任务到 EventLoop 线程池</span></span><br><span class="line">        safeExecute(executor, () -&gt; next.invokeBind(localAddress, promise), promise, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> promise; <span class="comment">// 返回 Promise 供调用者监听结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在当前 HandlerContext 中触发 bind 事件，调用对应处理器的 bind 方法。</span></span><br><span class="line"><span class="comment"> * 此方法会根据处理器类型进行不同的调用逻辑。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localAddress 要绑定的本地地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> promise 用于异步通知绑定结果的 Promise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查处理器是否启用（isRemoved() 为 false）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.handler();</span><br><span class="line">            DefaultChannelPipeline.<span class="type">HeadContext</span> <span class="variable">headContext</span> <span class="operator">=</span> <span class="built_in">this</span>.pipeline.head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据处理器类型选择调用方式</span></span><br><span class="line">            <span class="keyword">if</span> (handler == headContext) &#123;</span><br><span class="line">                <span class="comment">// 头部处理器：直接调用 HeadContext 的 bind 方法（最终触发底层网络绑定）</span></span><br><span class="line">                headContext.bind(<span class="built_in">this</span>, localAddress, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelDuplexHandler) &#123;</span><br><span class="line">                <span class="comment">// 双向处理器：调用其 bind 方法</span></span><br><span class="line">                ((ChannelDuplexHandler)handler).bind(<span class="built_in">this</span>, localAddress, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelOutboundHandlerAdapter) &#123;</span><br><span class="line">                <span class="comment">// 出站处理器适配器：调用其 bind 方法（默认实现会传递给下一个处理器）</span></span><br><span class="line">                ((ChannelOutboundHandlerAdapter)handler).bind(<span class="built_in">this</span>, localAddress, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他类型的出站处理器：强制转换并调用 bind 方法</span></span><br><span class="line">                ((ChannelOutboundHandler)handler).bind(<span class="built_in">this</span>, localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 处理异常：通知出站处理器链发生异常</span></span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理器已移除，将事件传递给下一个处理器</span></span><br><span class="line">        <span class="built_in">this</span>.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据handler的类型调用不同的bind方法</p>
<p><strong>以headContext为例：</strong></p>
<p>headContext这个bind方法会调用AbstractChannel的bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 Channel 到指定本地地址的底层绑定操作。</span></span><br><span class="line"><span class="comment"> * 此方法由 Channel 的 unsafe 接口实现，必须在 EventLoop 线程中调用。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localAddress 要绑定的本地地址（如 InetSocketAddress）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> promise 用于异步通知绑定结果的 Promise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 断言当前线程是 Channel 关联的 EventLoop 线程（确保线程安全）</span></span><br><span class="line">    <span class="built_in">this</span>.assertEventLoop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记 Promise 为不可取消，并检查 Channel 是否处于打开状态</span></span><br><span class="line">    <span class="keyword">if</span> (promise.setUncancellable() &amp;&amp; <span class="built_in">this</span>.ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="comment">// 处理广播地址警告（非 root 用户绑定非通配地址可能无法接收广播包）</span></span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.equals(AbstractChannel.<span class="built_in">this</span>.config().getOption(ChannelOption.SO_BROADCAST)) </span><br><span class="line">            &amp;&amp; localAddress <span class="keyword">instanceof</span> InetSocketAddress </span><br><span class="line">            &amp;&amp; !((InetSocketAddress)localAddress).getAddress().isAnyLocalAddress() </span><br><span class="line">            &amp;&amp; !PlatformDependent.isWindows() </span><br><span class="line">            &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;非 root 用户绑定非通配地址(&#123;&#125;)可能无法接收广播包，但仍按请求继续绑定&quot;</span>, localAddress);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录绑定前的 Channel 活跃状态</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasActive</span> <span class="operator">=</span> AbstractChannel.<span class="built_in">this</span>.isActive();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行实际的底层绑定操作（由子类实现，如 Java NIO 的 ServerSocketChannel.bind()）</span></span><br><span class="line">            AbstractChannel.<span class="built_in">this</span>.doBind(localAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 绑定失败处理：标记 Promise 为失败，并在 Channel 已关闭时执行清理</span></span><br><span class="line">            <span class="built_in">this</span>.safeSetFailure(promise, t);</span><br><span class="line">            <span class="built_in">this</span>.closeIfClosed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若绑定后 Channel 变为活跃状态（之前不活跃），触发 ChannelActive 事件</span></span><br><span class="line">        <span class="keyword">if</span> (!wasActive &amp;&amp; AbstractChannel.<span class="built_in">this</span>.isActive()) &#123;</span><br><span class="line">            <span class="comment">// 异步触发事件，避免在关键路径中执行用户代码</span></span><br><span class="line">            <span class="built_in">this</span>.invokeLater(() -&gt; AbstractChannel.<span class="built_in">this</span>.pipeline.fireChannelActive());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记 Promise 为成功</span></span><br><span class="line">        <span class="built_in">this</span>.safeSetSuccess(promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(SocketAddress var1)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>

<p>调用<code>ServerSocketChannel</code>的<code>doBind</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressJava6Requirement(</span></span><br><span class="line"><span class="meta">    reason = &quot;Usage guarded by java version check&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.javaChannel().bind(localAddress, <span class="built_in">this</span>.config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.javaChannel().socket().bind(localAddress, <span class="built_in">this</span>.config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ServerSocketChannel <span class="title function_">bind</span><span class="params">(SocketAddress local, <span class="type">int</span> backlog)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>上面的<code>bind</code>方法会调用ServerSocketChannelImpl的具体实现方法<code>bind</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 ServerSocketChannel 绑定到指定的本地地址，并设置最大连接队列长度。</span></span><br><span class="line"><span class="comment"> * 此方法是 Java NIO 底层网络操作的核心实现，用于创建 TCP 服务器。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> local 要绑定的本地地址（如 InetSocketAddress），若为 null 则绑定到通配地址（0.0.0.0）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> backlog 最大连接队列长度（等待 accept 的连接数），若小于 1 则使用默认值 50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 绑定后的 ServerSocketChannel 自身，支持链式调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 若发生 I/O 错误（如端口已被占用）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClosedChannelException 若 Channel 已关闭</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AlreadyBoundException 若 Channel 已绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ServerSocketChannel <span class="title function_">bind</span><span class="params">(SocketAddress local, <span class="type">int</span> backlog)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 使用内部锁确保操作的线程安全性（同一时间只能有一个线程执行绑定）</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>.lock) &#123;</span><br><span class="line">        <span class="comment">// 校验 Channel 状态：必须处于打开且未绑定状态</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClosedChannelException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.isBound()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBoundException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理地址参数：若为 null 则绑定到通配地址（0.0.0.0）并随机分配端口</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> local == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">0</span>) : Net.checkAddress(local);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 安全检查：验证当前线程是否有监听指定端口的权限</span></span><br><span class="line">        <span class="comment">// （例如：非 root 用户尝试监听 1-1023 之间的特权端口会被拒绝）</span></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            sm.checkListen(addr.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 平台相关的 TCP 绑定前准备（如设置 TCP 参数、权限检查等）</span></span><br><span class="line">        NetHooks.beforeTcpBind(<span class="built_in">this</span>.fd, addr.getAddress(), addr.getPort());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 执行底层 bind 操作（通过 JNI 调用操作系统的 socket.bind()）</span></span><br><span class="line">            <span class="comment">//    将套接字与指定 IP 地址和端口号关联</span></span><br><span class="line">            Net.bind(<span class="built_in">this</span>.fd, addr.getAddress(), addr.getPort());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 执行底层 listen 操作（通过 JNI 调用操作系统的 socket.listen()）</span></span><br><span class="line">            <span class="comment">//    将套接字转换为监听状态，开始接受客户端连接</span></span><br><span class="line">            <span class="comment">//    backlog 参数指定等待 accept 的最大连接数（TCP 半连接队列长度）</span></span><br><span class="line">            Net.listen(<span class="built_in">this</span>.fd, backlog &lt; <span class="number">1</span> ? <span class="number">50</span> : backlog);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 绑定失败时尝试关闭文件描述符，避免资源泄漏</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.fd.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                e.addSuppressed(suppressed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新本地地址信息（绑定成功后才能获取实际绑定的地址和端口）</span></span><br><span class="line">        <span class="comment">// 例如：若绑定到 0.0.0.0:0，这里会获取系统分配的实际端口号</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>.stateLock) &#123;</span><br><span class="line">            <span class="built_in">this</span>.localAddress = Net.localAddress(<span class="built_in">this</span>.fd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://xuanskeys.github.io">xuanskeys</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://xuanskeys.github.io/2025/05/13/Netty/">http://xuanskeys.github.io/2025/05/13/Netty/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://xuanskeys.github.io" target="_blank">XuanCode</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/1/">1</a></div><div class="post-share"><div class="social-share" data-image="/image/person.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/04/29/Vue3/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">Vue3（未完待续）vue3项目结构(Vite 构建工具) 1234567891011121314151617181920my-vue3-project/├── index.html                 # 入口 HTML 文件（必须位于根目录）├── package.json               # 项目依赖和脚本配置├── vite.config.js             # Vite 构建配置├── tsconfig.json              # TypeScript 配置（可选）├── .gitignore                 # Git 忽略规则├── public/                    # 静态资源（不会被构建工具处理）│   └── favicon.ico            # 网站图标└── src/                       # 源代码目录    ├── main.js/ts             # 项目入口文件    ├── App.vue               ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/21/CentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="CentOS 7环境搭建"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-21</div><div class="info-item-2">CentOS 7环境搭建</div></div><div class="info-2"><div class="info-item-1">CentOS 7环境搭建我的基础环境：  CentOS版本：CentOS Linux release 7.7.1908 (Core) Vmware版本：VMware® Workstation 17 Pro 17.5.0 build-22583795   注意：  所有有关防火墙的操作都可以不开端口，但是我为了测试方便我就开了端口号，便于后续本地测试，这个自行选择。 我所有的安装指令都是在root用户权限下执行的。 参考：软件安装 | CodeSheep 如有错误，欢迎指正！   1.验证网络连通性12ping 8.8.8.8ping www.baidu.com   连不通的，去修改一下&#x2F;etc&#x2F;resolv.conf下的dns配置 12345# /etc/resolv.confnameserver 223.5.5.5      # 阿里云主DNSnameserver 223.6.6.6      # 阿里云备DNSnameserver 114.114.114.114 # 114公共DNS（备用）nameserver 8.8.8.8        #...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC2/" title="Java并发编程2(锁-Sychronized)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java并发编程2(锁-Sychronized)</div></div><div class="info-2"><div class="info-item-1">认识Java对象头  32位虚拟机对象头：   64位虚拟机对象头：     1.Mark Word（标记字）:  Mark Word是对象头的一部分，用于存储对象自身的哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID（或偏向时间戳）、偏向模式以及锁的状态等信息。 标记字的大小和具体内容可能因JVM实现的不同而有所变化。例如，在64位JVM上，默认情况下Mark Word占用64位（8字节），而在32位JVM上则是32位（4字节）。  2.Class Pointer（类指针）:  这是指向该对象对应类（Class）的指针，通过这个指针可以访问到对象所属类的元数据（如方法表、字段描述等）。类指针的大小依赖于JVM的具体实现及其是否开启了压缩指针（Compressed Oop）选项。 在某些情况下，比如当使用了-XX:+UseCompressedClassPointers选项时，类指针会被压缩以节省内存。  3.Array...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC1/" title="JUC并发编程1(初识进程和线程)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">JUC并发编程1(初识进程和线程)</div></div><div class="info-2"><div class="info-item-1"> 初识进程和线程初识进程：定义：  进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。（百度百科） 进程由程序、数据和进程控制块三部分组成。   什么是进程？ 狭义定义：进程是正在运行的程序的实例。 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。   eg：进程可以看做是程序的实例，你可以打开多个程序，每一个程序就是一个进程（比如你重复打开QQ登录不同的用户，每一个用户登录的那个程序就是一个进程）。   如果你关闭一个窗口，那么这个进程也就结束了  概念：1.进程是一个实体。 ...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC3/" title="Java并发编程3(CAS)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java并发编程3(CAS)</div></div><div class="info-2"><div class="info-item-1">Java内存模型(JMM)概念百度百科：java内存模型_百度百科  Java内存模型（Java Memory Model,...</div></div></div></a><a class="pagination-related" href="/2025/04/27/JavaScript/" title="JavaScript"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-27</div><div class="info-item-2">JavaScript</div></div><div class="info-2"><div class="info-item-1">JavaScriptJavaScript是什么? JavaScript 是脚本语言  JavaScript 是一种轻量级的编程语言。  JavaScript 是可插入 HTML 页面的编程代码。  JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。   怎么定义？HTML 中的 Javascript 脚本代码必须位于  与  标签之间。 Javascript 脚本代码可被放置在 HTML 页面的  和  部分中。 JS显示数据 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。  JS数据格式数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e)。 字符串（String）字面量 可以使用单引号或双引号: 表达式字面量 用于计算：5 + 6 5 * 6 数组（Array）字面量 [40, 100, 1, 5, 25, 10] 对象（Object）字面量...</div></div></div></a><a class="pagination-related" href="/2025/04/20/JUC4/" title="Java并发编程4（JUC篇）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="info-item-2">Java并发编程4（JUC篇）</div></div><div class="info-2"><div class="info-item-1">本篇文章重点介绍JUC（java.util.concurrent）  JUC是”java.util.concurrent”包的简称，它是Java提供的一个并发工具包，旨在简化多线程编程，提供了丰富的类和接口来帮助开发者更高效、更安全地编写并发程序。JUC包增强了Java对并发的支持，解决了传统多线程编程中的一些难题，如死锁、竞争条件和资源管理等。    原子变量  基本类型原子变量 AtomicInteger  提供对整型值的原子操作，如加法、减法等。 方法示例：incrementAndGet(), decrementAndGet(), addAndGet(int delta), compareAndSet(int expect, int update)。  AtomicLong  类似于AtomicInteger，但是针对长整型（long）值。 方法与AtomicInteger相似，适用于需要处理较大数值的情况。  AtomicBoolean  支持布尔类型的原子操作。 方法示例：get(), set(boolean newValue),...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/person.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xuanskeys</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xuanskeys"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到XuanCode。更多详细信息请前往CSDN：https://blog.csdn.net/m0_73569492?type=blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">什么是Netty？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是Java IO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.2.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.BIO (阻塞IO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.NIO （非阻塞IO）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">1.Channel（通道）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">2. Buffer（缓冲区）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.2.2.2.3.</span> <span class="toc-text">3. Selector（选择器）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. I&#x2F;O 多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4.AIO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.Buffer(缓冲区)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">（1）核心方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">（2）状态切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">（3）读写方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">1. 基本读写方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">2.批量读写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">（4）标记与重置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">（5）工具方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">（6）视图与复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">区别（Channel和Stream）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">实现子类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">FileChannel类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">SocketChannel类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">ServerSocketChannel类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">DatagramChannel类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">核心特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.4.</span> <span class="toc-text">聊天案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.5.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">什么是零拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">传统 I&#x2F;O 的数据拷贝流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">零拷贝的两种常见实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">mmap 和 sendFile 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">传统 I&#x2F;O vs NIO 零拷贝的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.5.6.</span> <span class="toc-text">DMA和内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.5.7.</span> <span class="toc-text">零拷贝性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.3.5.7.1.</span> <span class="toc-text">不使用零拷贝：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.3.5.7.2.</span> <span class="toc-text">使用零拷贝：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Reactor模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">什么是Reactor模式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.1.</span> <span class="toc-text">理解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.2.</span> <span class="toc-text">主要逻辑：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">单Reactor单线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.1.</span> <span class="toc-text">键值存储服务器:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.3.</span> <span class="toc-text">单 Reactor 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.3.1.</span> <span class="toc-text">简单HTTP 服务器：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.4.</span> <span class="toc-text">主从 Reactor 多线程案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.4.1.</span> <span class="toc-text">简易Http服务器：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text">线程模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text">核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.1.</span> <span class="toc-text">ServerBootstrap（服务器启动类）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">核心作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">关键方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.2.</span> <span class="toc-text">Bootstrap（客户端启动类）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">核心作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">关键方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.3.</span> <span class="toc-text">EventLoopGroup 与 EventLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.4.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.5.</span> <span class="toc-text">ChannelPipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.6.</span> <span class="toc-text">ChannelHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">案例分析（群聊系统）：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text">服务器：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">ChatServer.class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">ChatServerHandler.class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">ChatConnectionServerHandler.class</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.2.</span> <span class="toc-text">客户端：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">ChatClient.class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">ChatClientHandler.class</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.3.</span> <span class="toc-text">运行结果：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Netty源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.1.</span> <span class="toc-text">EventLoopGroup 和EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.1.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.2.</span> <span class="toc-text">NioEventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">重要字段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.2.0.1.1.</span> <span class="toc-text">1.Selector相关字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.2.0.1.2.</span> <span class="toc-text">2.任务队列相关字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.2.0.1.3.</span> <span class="toc-text">3.父级EventLoopGroup</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.2.0.1.4.</span> <span class="toc-text">4.线程相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.2.0.1.5.</span> <span class="toc-text">5.事件相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.2.0.1.6.</span> <span class="toc-text">6. 时间与执行控制属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.2.0.3.</span> <span class="toc-text">重要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.2.0.3.1.</span> <span class="toc-text">run方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">5.2.0.3.1.1.</span> <span class="toc-text">**select(curDeadlineNanos)**：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">5.2.0.3.1.2.</span> <span class="toc-text">**processSelectedKeys**：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">5.2.0.3.1.3.</span> <span class="toc-text">**runAllTasks(long timeoutNanos)**：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.3.</span> <span class="toc-text">NioEventLoopGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.3.1.</span> <span class="toc-text">重要字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">1. 线程池相关字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">2. 线程配置字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">3. Selector 配置字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.1.4.</span> <span class="toc-text">4. 拒绝策略和任务队列字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.3.2.</span> <span class="toc-text">重要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">1. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">2. 线程选择方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">3. Channel 注册方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.2.4.</span> <span class="toc-text">4. 优雅关闭方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.2.5.</span> <span class="toc-text">5. 任务提交方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.2.6.</span> <span class="toc-text">6. 资源清理方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.3.3.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.3.4.</span> <span class="toc-text">初始化逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.4.1.</span> <span class="toc-text">1.初始化EventLoop数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.3.4.2.</span> <span class="toc-text">3.初始化选择器chooser：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.3.5.</span> <span class="toc-text">核心逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.4.</span> <span class="toc-text">AbstractChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.4.1.</span> <span class="toc-text">属性字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.4.2.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.5.</span> <span class="toc-text">Netty服务器启动源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.5.1.</span> <span class="toc-text">1.初始化EventLoopGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.5.2.</span> <span class="toc-text">2.初始化channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.5.3.</span> <span class="toc-text">3.初始化处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.5.3.0.1.</span> <span class="toc-text">初始化主通道处理器(handler())</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">5.5.3.0.2.</span> <span class="toc-text">初始化子通道处理器(childHandler())</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.5.4.</span> <span class="toc-text">4.绑定端口并启动服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.5.4.1.</span> <span class="toc-text">4.1.初始化并注册Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.5.4.2.</span> <span class="toc-text">4.2 根据注册结果处理绑定</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/13/Netty/" title="Netty">Netty</a><time datetime="2025-05-13T15:15:00.000Z" title="发表于 2025-05-13 23:15:00">2025-05-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/29/Vue3/" title="无标题">无标题</a><time datetime="2025-04-29T09:51:08.718Z" title="发表于 2025-04-29 17:51:08">2025-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/27/JavaScript/" title="JavaScript">JavaScript</a><time datetime="2025-04-27T00:24:00.000Z" title="发表于 2025-04-27 08:24:00">2025-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/26/Spring%20MVC/" title="Spring MVC">Spring MVC</a><time datetime="2025-04-26T00:24:00.000Z" title="发表于 2025-04-26 08:24:00">2025-04-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/24/WebSocket/" title="无标题">无标题</a><time datetime="2025-04-24T11:57:33.742Z" title="发表于 2025-04-24 19:57:33">2025-04-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By xuanskeys</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: 'xuanskeys.github.io',
      owner: 'xuanskeys',
      admin: ['xuanskeys'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'ff4d602f956737f53d5a7c68c695e745'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>